import { Tournament, Player } from "..";
import { DeepPartial } from "../../utils/DeepPartial";
import { Design } from '../../Design';
import { Agent } from "../../Agent";
import { Dimension, NanoID } from "../../Dimension";
import LadderState = Ladder.State;
import LadderConfigs = Ladder.Configs;
import LadderPlayerStat = Ladder.PlayerStat;
import { nanoid } from "../..";
/**
 * The Ladder Tournament class and namespace.
 */
export declare class Ladder extends Tournament {
    configs: Tournament.TournamentConfigs<LadderConfigs>;
    state: LadderState;
    /**
     * ELO System used in this tournament
     */
    private elo;
    /**
     * tournament runner interval, periodically calls tourneyRunner to start up new matches
     */
    private runInterval;
    /**
     * Configuration synchronization interval. Periodically makes a request to the DB if there is one and changes configs
     */
    private configSyncInterval;
    /**
     * Last modification date of configs
     */
    private configLastModificationDate;
    resultProcessingQueue: Array<{
        result: any;
        mapAgentIDtoTournamentID: Map<Agent.ID, Tournament.ID>;
    }>;
    constructor(design: Design, files: Array<string> | Array<{
        file: string;
        name: string;
        existingID?: string;
    }>, tournamentConfigs: Tournament.TournamentConfigsBase, id: NanoID, dimension: Dimension);
    /**
     * Sync configs from DB
     */
    private syncConfigs;
    private setupConfigSyncInterval;
    /**
     * Retrieves the local configurations
     */
    getConfigs(): Tournament.TournamentConfigs<LadderConfigs>;
    /**
     * Set tournament status and updates DB / propagates the message to every other tournament instance
     */
    setStatus(status: Tournament.Status): Promise<void>;
    /**
     * Sets configs and updates DB / propagates the message to every other tournament instance
     */
    setConfigs(configs?: DeepPartial<Tournament.TournamentConfigs<LadderConfigs>>): Promise<void>;
    getRankings(offset?: number, limit?: number): Promise<Array<LadderPlayerStat>>;
    /**
     * Resets rankings of all competitors loaded to initial scores
     */
    resetRankings(): Promise<void>;
    /**
     * Stops the tournament if it was running.
     * @param master - whether or not the instance calling stop was the first one, the "master" instance
     */
    stop(master?: boolean): Promise<void>;
    /**
     * Resumes the tournament if it was stopped.
     * @param master - whether or not the instance calling stop was the first one, the "master" instance
     */
    resume(master?: boolean): Promise<void>;
    /**
     * Begin the tournament. Resolves once the tournament is started
     * @param configs - tournament configurations to use
     * @param master - whether or not the instance calling stop was the first one, the "master" instance
     */
    run(configs?: DeepPartial<Tournament.TournamentConfigs<LadderConfigs>>, master?: boolean): Promise<void>;
    private tourneyRunner;
    /**
     * Performs a Fisher Yates Shuffle
     * @param arr - the array to shuffle
     */
    private shuffle;
    /**
     * Updates database with trueskill player stats
     * Requires special handling because of the way the trueskill module works
     *
     * If failure occurs, we ignore it and just log it as we will likely in the future perform an update operation
     * on the database again anyway
     *
     * @param playerStat
     * @param user
     */
    private updateDatabaseTrueskillPlayerStats;
    /**
    * Updates database with ELO player stats
    *
    * If failure occurs, we ignore it and just log it as we will likely in the future perform an update operation
    * on the database again anyway
    *
    * @param playerStat
    * @param user
    */
    private updateDatabaseELOPlayerStats;
    /**
     * Initialize trueskill player stats. Pulls data from database if it exists and uses past stats to fill in
     * @param player
     *
     * This is probably a nightmare to test
     */
    private initializeTrueskillPlayerStats;
    private initializeELOPlayerStats;
    /**
     * Initialize competition with local competitors given and store player stats locally
     *
     * Does not read in any DB players
     */
    initialize(): Promise<void>;
    /**
     * Schedules matches to play. Default function is to schedule randomly a player A with other players that are within
     * 2.5 * competitorCount rank of that player A's rank. competitorCount is the number of agents chosen to compete
     * in the particular match to schedule. See {@link Tournament.TournamentConfigs.agentsPerMatch}.
     *
     * If a {@link Ladder.Configs.matchMake | matchMake} function is provided, that will be used instead of the default.
     */
    private schedule;
    private selectRandomAgentAmountForMatch;
    private selectRandomplayersFromArray;
    internalAddPlayer(player: Player): Promise<void>;
    updatePlayer(player: Player, oldname: string, oldfile: string): Promise<void>;
    /**
     * Removes player from tournament. Removes from state and stats from database
     * @param playerID
     */
    internalRemovePlayer(playerID: nanoid): Promise<void>;
    /**
     * Print tournament status to display
     */
    private printTournamentStatus;
    /**
     * Checks whether match can still be run
     */
    private checkMatchIntegrity;
    /**
     * Handles the start and end of a match, and updates state accrding to match results and the given result handler
     * @param matchInfo
     */
    private handleMatch;
    /**
     * Update player stats for whoever stats owns this. Determined by checking the player field of
     * {@link Ladder.PlayerStat}
     */
    private updatePlayerStat;
    /**
     * Handles match results.
     *
     * If match result is {ranks: []}, nothing will happen, can be used to mark a match as having errored
     */
    private handleMatchWithTrueSkill;
    private handleMatchWithELO;
    protected preInternalDestroy(): Promise<void>;
}
/**
 * The Ladder Tournament namespace
 */
export declare namespace Ladder {
    /**
     * Configuration interface for {@link LadderTournament}.
     */
    interface Configs extends Tournament.TournamentTypeConfig {
        /** Max matches that can run concurrently on one node instance
         * @default 1
         */
        maxConcurrentMatches: number;
        /** The date to stop running this tournament once it is started. If null, no end date
         * @default null
         */
        endDate: Date;
        /** The max matches to run before stopping the tournament. If null, then no maximum
         * @default null
         */
        maxTotalMatches: number;
        /**
         * Custom match making scheduler function. User can provide a custom function here to create matches to store
         * into the matchqueue for {@link Match} making. This function will be called every time the number of queued
         * matches is below a threshold of {@link maxConcurrentMatches} * 2.
         *
         * It should return an array of {@link Player } arrays, a list of all the new matches to append to the matchQueue.
         * A player array represents a queued match and the players that will compete in that match.
         *
         *
         * Default function is described in {@link schedule}
         *
         */
        matchMake: 
        /**
         * @param playerStats - an array of all player stats in the tournament. See {@link PlayerStat} for what variables
         * are exposed to use to help schedule matches
         */
        (playerStats: Array<PlayerStat>) => Array<Array<Player>>;
        /**
         * Rate in ms of how fast to sync the configs. Used for synchronizing configs in a distributed system.
         *
         * @default `6000`
         */
        configSyncRefreshRate: number;
    }
    /**
     * The {@link LadderTournament} state, consisting of the current player statistics and past results
     */
    interface State extends Tournament.TournamentTypeState {
        /**
         * A map from a {@link Player} Tournament ID string to statistics
         */
        playerStats: Map<NanoID, PlayerStat>;
        /**
         * Stats for this Tournament in this instance. Intended to be constant memory usage
         */
        statistics: {
            totalMatches: number;
        };
        currentRanks: Array<{
            player: Player;
            rankState: any;
        }>;
    }
    /**
     * Player stat interface for ladder tournaments
     */
    interface PlayerStat extends Tournament.PlayerStatBase {
        wins: number;
        ties: number;
        losses: number;
        /**
         * total matches played
         */
        matchesPlayed: number;
        /**
         * the ranking statistics for the player. the type of this variable is dependent on the ranking system you use for
         * the tournament. If the ranking system is {@link RankSystem.TRUESKILL | Trueskill}, then see
         * {@link RankSystem.TRUESKILL.RankState} for the rank state typings.
         */
        rankState: any;
    }
}
