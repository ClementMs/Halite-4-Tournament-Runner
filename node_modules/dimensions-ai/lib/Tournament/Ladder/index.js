"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("..");
var DeepMerge_1 = require("../../utils/DeepMerge");
var DimensionError_1 = require("../../DimensionError");
var ts_trueskill_1 = require("ts-trueskill");
var sprintf_js_1 = require("sprintf-js");
var Logger_1 = require("../../Logger");
var ELO_1 = require("../ELO");
var TournamentStatus_1 = require("../TournamentStatus");
var RankSystem_1 = require("../RankSystem");
var TournamentTypes_1 = require("../TournamentTypes");
var DeepCopy_1 = require("../../utils/DeepCopy");
var REFRESH_RATE = 10000;
/**
 * The Ladder Tournament class and namespace.
 */
var Ladder = /** @class */ (function (_super) {
    __extends(Ladder, _super);
    function Ladder(design, files, tournamentConfigs, id, dimension) {
        var _this = _super.call(this, design, files, id, tournamentConfigs, dimension) || this;
        _this.configs = {
            defaultMatchConfigs: {},
            type: TournamentTypes_1.TournamentType.LADDER,
            rankSystem: null,
            rankSystemConfigs: null,
            tournamentConfigs: {
                maxConcurrentMatches: 1,
                endDate: null,
                storePastResults: true,
                maxTotalMatches: null,
                matchMake: null,
                configSyncRefreshRate: 6000
            },
            resultHandler: null,
            agentsPerMatch: [2],
            consoleDisplay: true,
            id: 'z3plg'
        };
        _this.state = {
            playerStats: new Map(),
            currentRanks: [],
            results: [],
            statistics: {
                totalMatches: 0
            }
        };
        /**
         * tournament runner interval, periodically calls tourneyRunner to start up new matches
         */
        _this.runInterval = null;
        /**
         * Configuration synchronization interval. Periodically makes a request to the DB if there is one and changes configs
         */
        _this.configSyncInterval = null;
        /**
         * Last modification date of configs
         */
        _this.configLastModificationDate = new Date(0);
        // queue of the results to process
        _this.resultProcessingQueue = [];
        _this.configs = DeepMerge_1.deepMerge(_this.configs, tournamentConfigs, true);
        switch (_this.configs.rankSystem) {
            case RankSystem_1.RankSystem.TRUESKILL:
                if (_this.configs.rankSystemConfigs === null) {
                    // set default rank system configs
                    var trueskillConfigs = {
                        initialMu: 25,
                        initialSigma: 25 / 3
                    };
                    _this.configs.rankSystemConfigs = trueskillConfigs;
                }
                break;
            case RankSystem_1.RankSystem.ELO:
                if (_this.configs.rankSystemConfigs === null) {
                    // set default rank system configs
                    var eloConfigs = {
                        startingScore: 1000,
                        kFactor: 32
                    };
                    _this.configs.rankSystemConfigs = eloConfigs;
                }
                _this.elo = new ELO_1.ELOSystem(_this.configs.rankSystemConfigs.kFactor, _this.configs.rankSystemConfigs.startingScore);
                break;
            default:
                throw new DimensionError_1.NotSupportedError('We currently do not support this rank system for ladder tournaments');
        }
        files.forEach(function (file) {
            if (typeof file === 'string') {
                _this.initialAddPlayerPromises.push(_this.addplayer(file));
            }
            else {
                _this.initialAddPlayerPromises.push(_this.addplayer(file, file.existingID));
            }
        });
        _this.status = TournamentStatus_1.TournamentStatus.INITIALIZED;
        // setup config syncing if DB is enabled and store configs if not stored already
        if (_this.dimension.hasDatabase()) {
            _this.syncConfigs();
            _this.setupConfigSyncInterval();
            _this.dimension.databasePlugin.getTournamentConfigs(_this.id).then(function (data) {
                if (!data) {
                    _this.configLastModificationDate = new Date();
                    _this.dimension.databasePlugin.storeTournamentConfigs(_this.id, _this.configs, _this.status).then(function () {
                        _this.log.error('Storing initial tournament configuration data');
                    });
                }
            });
        }
        _this.log.info('Initialized Ladder Tournament');
        return _this;
    }
    /**
     * Sync configs from DB
     */
    Ladder.prototype.syncConfigs = function () {
        return __awaiter(this, void 0, void 0, function () {
            var modDate, _a, configs, status_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.dimension.databasePlugin.getTournamentConfigsModificationDate(this.id)];
                    case 1:
                        modDate = _b.sent();
                        if (!(modDate && modDate.getTime() > this.configLastModificationDate.getTime())) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.dimension.databasePlugin.getTournamentConfigs(this.id)];
                    case 2:
                        _a = _b.sent(), configs = _a.configs, status_1 = _a.status;
                        this.log.info("Received new configurations, mod date - " + modDate);
                        this.log.detail(configs);
                        this.configLastModificationDate = modDate;
                        this.configs = DeepMerge_1.deepMerge(this.configs, configs, true);
                        // update status and run/stop/resume tourney as needed
                        if (status_1 !== this.status) {
                            if (status_1 === __1.Tournament.Status.STOPPED) {
                                if (this.status === __1.Tournament.Status.RUNNING) {
                                    this.stop();
                                }
                            }
                            else if (status_1 === __1.Tournament.Status.RUNNING) {
                                if (this.status === __1.Tournament.Status.INITIALIZED) {
                                    this.run();
                                }
                                else if (this.status === __1.Tournament.Status.STOPPED) {
                                    this.resume();
                                }
                            }
                        }
                        _b.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    Ladder.prototype.setupConfigSyncInterval = function () {
        var _this = this;
        this.configSyncInterval = setInterval(function () {
            _this.syncConfigs();
        }, this.configs.tournamentConfigs.configSyncRefreshRate);
    };
    /**
     * Retrieves the local configurations
     */
    Ladder.prototype.getConfigs = function () {
        return this.configs;
    };
    /**
     * Set tournament status and updates DB / propagates the message to every other tournament instance
     */
    Ladder.prototype.setStatus = function (status) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.dimension.hasDatabase()) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.syncConfigs()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.dimension.databasePlugin.storeTournamentConfigs(this.id, this.configs, status)];
                    case 2:
                        _a.sent();
                        this.status = status;
                        return [3 /*break*/, 4];
                    case 3:
                        this.status = status;
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets configs and updates DB / propagates the message to every other tournament instance
     */
    Ladder.prototype.setConfigs = function (configs) {
        if (configs === void 0) { configs = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var plugin_1;
            var _this = this;
            return __generator(this, function (_a) {
                if (configs.id) {
                    throw new DimensionError_1.TournamentError('You cannot change the tournament ID after constructing the tournament');
                }
                if (this.dimension.hasDatabase()) {
                    plugin_1 = this.dimension.databasePlugin;
                    // ensure configs are up to date first, then set configs
                    this.syncConfigs().then(function () {
                        var newconfigs = DeepMerge_1.deepMerge(DeepCopy_1.deepCopy(_this.configs), configs, true);
                        plugin_1.storeTournamentConfigs(_this.id, newconfigs, _this.status).then(function () {
                            // set configs locally as well if we succesfully store into DB
                            _this.configs = newconfigs;
                        });
                    });
                }
                else {
                    this.configs = DeepMerge_1.deepMerge(this.configs, configs, true);
                }
                return [2 /*return*/];
            });
        });
    };
    Ladder.prototype.getRankings = function (offset, limit) {
        if (offset === void 0) { offset = 0; }
        if (limit === void 0) { limit = -1; }
        return __awaiter(this, void 0, void 0, function () {
            var rankings, _a;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        rankings = [];
                        _a = this.configs.rankSystem;
                        switch (_a) {
                            case RankSystem_1.RankSystem.TRUESKILL: return [3 /*break*/, 1];
                            case RankSystem_1.RankSystem.ELO: return [3 /*break*/, 5];
                        }
                        return [3 /*break*/, 9];
                    case 1:
                        if (!this.dimension.hasDatabase()) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.dimension.databasePlugin.getRanks(this, offset, limit)];
                    case 2:
                        rankings = _b.sent();
                        rankings = rankings.map(function (rank) {
                            rank.rankState.score = rank.rankState.rating.mu - 3 * rank.rankState.rating.sigma;
                            return rank;
                        });
                        if (this.anonymousCompetitors.size > 0) {
                            // add in anonymous competitors in
                            this.anonymousCompetitors.forEach(function (player) {
                                var stat = _this.state.playerStats.get(player.tournamentID.id);
                                var rankState = stat.rankState;
                                rankings.push({
                                    player: stat.player,
                                    name: stat.player.tournamentID.name,
                                    id: stat.player.tournamentID.id,
                                    matchesPlayed: stat.matchesPlayed,
                                    rankState: { rating: __assign(__assign({}, rankState.rating), { mu: rankState.rating.mu, sigma: rankState.rating.sigma }), score: rankState.rating.mu - 3 * rankState.rating.sigma }
                                });
                            });
                            // re sort
                            rankings.sort(function (a, b) {
                                return b.rankState.score - a.rankState.score;
                            });
                        }
                        return [3 /*break*/, 9];
                    case 3:
                        this.state.playerStats.forEach(function (stat) {
                            var rankState = stat.rankState;
                            rankings.push({
                                player: stat.player,
                                name: stat.player.tournamentID.name,
                                id: stat.player.tournamentID.id,
                                matchesPlayed: stat.matchesPlayed,
                                rankState: { rating: __assign(__assign({}, rankState.rating), { mu: rankState.rating.mu, sigma: rankState.rating.sigma }), score: rankState.rating.mu - 3 * rankState.rating.sigma }
                            });
                        });
                        _b.label = 4;
                    case 4:
                        rankings.sort(function (a, b) {
                            return b.rankState.score - a.rankState.score;
                        });
                        return [3 /*break*/, 9];
                    case 5:
                        if (!this.dimension.hasDatabase()) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.dimension.databasePlugin.getRanks(this, offset, limit)];
                    case 6:
                        rankings = _b.sent();
                        if (this.anonymousCompetitors.size > 0) {
                            // add in anonymous competitors in
                            this.anonymousCompetitors.forEach(function (player) {
                                var stat = _this.state.playerStats.get(player.tournamentID.id);
                                var rankState = stat.rankState;
                                rankings.push({
                                    player: stat.player,
                                    name: stat.player.tournamentID.name,
                                    id: stat.player.tournamentID.id,
                                    matchesPlayed: stat.matchesPlayed,
                                    rankState: rankState
                                });
                            });
                            // re sort
                            rankings.sort(function (a, b) {
                                return b.rankState.rating.score - a.rankState.rating.score;
                            });
                        }
                        return [3 /*break*/, 9];
                    case 7:
                        this.state.playerStats.forEach(function (stat) {
                            var rankState = stat.rankState;
                            rankings.push({
                                player: stat.player,
                                name: stat.player.tournamentID.name,
                                id: stat.player.tournamentID.id,
                                matchesPlayed: stat.matchesPlayed,
                                rankState: rankState
                            });
                        });
                        _b.label = 8;
                    case 8:
                        rankings.sort(function (a, b) {
                            return b.rankState.rating.score - a.rankState.rating.score;
                        });
                        return [3 /*break*/, 9];
                    case 9: return [2 /*return*/, rankings];
                }
            });
        });
    };
    /**
     * Resets rankings of all competitors loaded to initial scores
     */
    Ladder.prototype.resetRankings = function () {
        return __awaiter(this, void 0, void 0, function () {
            var updatePromises, playerStatsList, userList;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.status == TournamentStatus_1.TournamentStatus.RUNNING) {
                            throw new DimensionError_1.TournamentError('Cannot reset while tournament is running!');
                        }
                        updatePromises = [];
                        playerStatsList = [];
                        userList = [];
                        if (!this.dimension.hasDatabase()) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.dimension.databasePlugin.getUsersInTournament(this.getKeyName(), 0, -1)];
                    case 1:
                        // get every user
                        userList = (_a.sent());
                        playerStatsList = userList.map(function (user) { return user.statistics[_this.getKeyName()]; });
                        // add anonymous users
                        playerStatsList.push.apply(playerStatsList, (Array.from(this.state.playerStats.values())));
                        return [3 /*break*/, 3];
                    case 2:
                        playerStatsList = Array.from(this.state.playerStats.values());
                        _a.label = 3;
                    case 3:
                        playerStatsList.forEach(function (stats, i) {
                            var resetPlayer = function () { return __awaiter(_this, void 0, void 0, function () {
                                var trueskillConfigs;
                                return __generator(this, function (_a) {
                                    switch (this.configs.rankSystem) {
                                        case RankSystem_1.RankSystem.TRUESKILL:
                                            stats.matchesPlayed = 0;
                                            trueskillConfigs = this.configs.rankSystemConfigs;
                                            stats.rankState = {
                                                rating: new ts_trueskill_1.Rating(trueskillConfigs.initialMu, trueskillConfigs.initialSigma)
                                            };
                                            if (this.dimension.hasDatabase()) {
                                                this.updateDatabaseTrueskillPlayerStats(stats, userList[i]);
                                            }
                                            break;
                                        case RankSystem_1.RankSystem.ELO:
                                            stats.matchesPlayed = 0;
                                            stats.rankState = {
                                                rating: this.elo.createRating()
                                            };
                                            if (this.dimension.hasDatabase()) {
                                                this.updateDatabaseELOPlayerStats(stats, userList[i]);
                                            }
                                            break;
                                    }
                                    return [2 /*return*/];
                                });
                            }); };
                            updatePromises.push(resetPlayer());
                        });
                        return [4 /*yield*/, Promise.all(updatePromises)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Stops the tournament if it was running.
     * @param master - whether or not the instance calling stop was the first one, the "master" instance
     */
    Ladder.prototype.stop = function (master) {
        if (master === void 0) { master = false; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.status !== TournamentStatus_1.TournamentStatus.RUNNING) {
                            throw new DimensionError_1.TournamentError("Can't stop a tournament that isn't running");
                        }
                        this.log.info('Stopping Tournament...');
                        clearInterval(this.runInterval);
                        if (!master) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.setStatus(TournamentStatus_1.TournamentStatus.STOPPED)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        this.status = TournamentStatus_1.TournamentStatus.STOPPED;
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Resumes the tournament if it was stopped.
     * @param master - whether or not the instance calling stop was the first one, the "master" instance
     */
    Ladder.prototype.resume = function (master) {
        if (master === void 0) { master = false; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.status !== TournamentStatus_1.TournamentStatus.STOPPED) {
                            throw new DimensionError_1.TournamentError("Can't resume a tournament that isn't stopped");
                        }
                        this.log.info('Resuming Tournament...');
                        if (!master) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.setStatus(TournamentStatus_1.TournamentStatus.RUNNING)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        this.status = TournamentStatus_1.TournamentStatus.RUNNING;
                        _a.label = 3;
                    case 3:
                        this.tourneyRunner();
                        this.runInterval = setInterval(function () {
                            _this.tourneyRunner();
                        }, REFRESH_RATE);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Begin the tournament. Resolves once the tournament is started
     * @param configs - tournament configurations to use
     * @param master - whether or not the instance calling stop was the first one, the "master" instance
     */
    Ladder.prototype.run = function (configs, master) {
        if (master === void 0) { master = false; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.log.info('Running Tournament');
                        this.configs = DeepMerge_1.deepMerge(this.configs, configs, true);
                        return [4 /*yield*/, this.initialize()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.schedule()];
                    case 2:
                        _a.sent();
                        if (master) {
                            this.setStatus(TournamentStatus_1.TournamentStatus.RUNNING);
                        }
                        else {
                            this.status = TournamentStatus_1.TournamentStatus.RUNNING;
                        }
                        this.tourneyRunner();
                        this.runInterval = setInterval(function () {
                            _this.tourneyRunner();
                        }, REFRESH_RATE);
                        return [2 /*return*/];
                }
            });
        });
    };
    Ladder.prototype.tourneyRunner = function () {
        return __awaiter(this, void 0, void 0, function () {
            var maxTotalMatches, currDate, matchPromises, i, matchInfo;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.matches.size >= this.configs.tournamentConfigs.maxConcurrentMatches)
                            return [2 /*return*/];
                        maxTotalMatches = this.configs.tournamentConfigs.maxTotalMatches;
                        if (this.configs.tournamentConfigs.endDate) {
                            currDate = new Date();
                            if (currDate.getTime() > this.configs.tournamentConfigs.endDate.getTime()) {
                                this.log.info('Reached past Tournament marked End Date, shutting down tournament...');
                                // stop the tournament
                                this.stop();
                                return [2 /*return*/];
                            }
                        }
                        if (maxTotalMatches) {
                            if (this.state.statistics.totalMatches >= maxTotalMatches) {
                                this.log.info('Reached max matches, shutting down tournament...');
                                this.stop();
                                return [2 /*return*/];
                            }
                        }
                        matchPromises = [];
                        if (!(this.matchQueue.length < this.configs.tournamentConfigs.maxConcurrentMatches * 2)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.schedule()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        // run as the minimum of the queued matches length, minimum to not go over maxConcurrent matches config, and not to go over a maxtTotalMatches limit if there is one
                        for (i = 0; i < Math.min(this.matchQueue.length, this.configs.tournamentConfigs.maxConcurrentMatches - this.matches.size); i++) {
                            if (maxTotalMatches && maxTotalMatches - this.state.statistics.totalMatches - this.matches.size <= 0) {
                                break;
                            }
                            matchInfo = this.matchQueue.shift();
                            matchPromises.push(this.handleMatch(matchInfo));
                        }
                        // as soon as one match finished, call it again
                        Promise.race(matchPromises).then(function () {
                            if (_this.status == TournamentStatus_1.TournamentStatus.RUNNING) {
                                _this.tourneyRunner();
                            }
                        }).catch(function (error) {
                            _this.log.error(error);
                            if (error instanceof DimensionError_1.MatchDestroyedError) {
                                // keep running even if a match is destroyed and the tournament is marked as to keep running
                                if (_this.status == TournamentStatus_1.TournamentStatus.RUNNING) {
                                    _this.tourneyRunner();
                                }
                            }
                            else {
                                if (_this.status == TournamentStatus_1.TournamentStatus.RUNNING) {
                                    _this.tourneyRunner();
                                }
                            }
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Performs a Fisher Yates Shuffle
     * @param arr - the array to shuffle
     */
    Ladder.prototype.shuffle = function (arr) {
        for (var i = arr.length - 1; i >= 1; i--) {
            var j = Math.floor(Math.random() * i);
            var tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
        }
        return arr;
    };
    /**
     * Updates database with trueskill player stats
     * Requires special handling because of the way the trueskill module works
     *
     * If failure occurs, we ignore it and just log it as we will likely in the future perform an update operation
     * on the database again anyway
     *
     * @param playerStat
     * @param user
     */
    Ladder.prototype.updateDatabaseTrueskillPlayerStats = function (playerStat, user) {
        return __awaiter(this, void 0, void 0, function () {
            var player, keyName, update, rankStateRating, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        player = playerStat.player;
                        if (!!player.anonymous) return [3 /*break*/, 4];
                        keyName = this.getKeyName();
                        update = {
                            statistics: {}
                        };
                        // if there exists stats already, keep them
                        if (user && user.statistics) {
                            update.statistics = user.statistics;
                        }
                        // perform update
                        update.statistics[keyName] = playerStat;
                        rankStateRating = update.statistics[keyName].rankState.rating;
                        // make sure to store mu and sigma
                        update.statistics[keyName].rankState = {
                            rating: __assign(__assign({}, rankStateRating), { mu: rankStateRating.mu, sigma: rankStateRating.sigma })
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.dimension.databasePlugin.updateUser(player.tournamentID.id, update)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        this.log.error("Failed to update user with player stats", err_1);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
    * Updates database with ELO player stats
    *
    * If failure occurs, we ignore it and just log it as we will likely in the future perform an update operation
    * on the database again anyway
    *
    * @param playerStat
    * @param user
    */
    Ladder.prototype.updateDatabaseELOPlayerStats = function (playerStat, user) {
        return __awaiter(this, void 0, void 0, function () {
            var player, keyName, update, err_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        player = playerStat.player;
                        if (!!player.anonymous) return [3 /*break*/, 4];
                        keyName = this.getKeyName();
                        update = {
                            statistics: {}
                        };
                        // if there exists stats already, keep them
                        if (user && user.statistics) {
                            update.statistics = user.statistics;
                        }
                        // perform update
                        update.statistics[keyName] = playerStat;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.dimension.databasePlugin.updateUser(player.tournamentID.id, update)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_2 = _a.sent();
                        this.log.error("Failed to update user with player stats", err_2);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Initialize trueskill player stats. Pulls data from database if it exists and uses past stats to fill in
     * @param player
     *
     * This is probably a nightmare to test
     */
    Ladder.prototype.initializeTrueskillPlayerStats = function (player) {
        return __awaiter(this, void 0, void 0, function () {
            var trueskillConfigs, playerStat, user, keyName;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        trueskillConfigs = this.configs.rankSystemConfigs;
                        playerStat = null;
                        keyName = this.getKeyName();
                        if (!(!player.anonymous && this.dimension.hasDatabase())) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.dimension.databasePlugin.getUser(player.tournamentID.id)];
                    case 1:
                        user = _a.sent();
                        if (user) {
                            // if there are stats
                            if (user.statistics) {
                                playerStat = user.statistics[keyName];
                                if (playerStat) {
                                    playerStat.rankState = {
                                        rating: new ts_trueskill_1.Rating(playerStat.rankState.rating.mu, playerStat.rankState.rating.sigma)
                                    };
                                    // make sure its referenced to right player object still
                                    playerStat.player = player;
                                }
                            }
                        }
                        _a.label = 2;
                    case 2:
                        // Initialize to default values
                        if (!playerStat) {
                            playerStat = {
                                player: player,
                                wins: 0,
                                ties: 0,
                                losses: 0,
                                matchesPlayed: 0,
                                rankState: {
                                    rating: new ts_trueskill_1.Rating(trueskillConfigs.initialMu, trueskillConfigs.initialSigma)
                                }
                            };
                            this.updateDatabaseTrueskillPlayerStats(playerStat, user);
                        }
                        // only store locally if not in DB
                        if (!user) {
                            this.state.playerStats.set(player.tournamentID.id, playerStat);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Ladder.prototype.initializeELOPlayerStats = function (player) {
        return __awaiter(this, void 0, void 0, function () {
            var playerStat, user, update;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        playerStat = null;
                        if (!(!player.anonymous && this.dimension.hasDatabase())) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.dimension.databasePlugin.getUser(player.tournamentID.id)];
                    case 1:
                        user = _a.sent();
                        if (user) {
                            if (user.statistics) {
                                playerStat = user.statistics["" + this.getKeyName()];
                            }
                        }
                        _a.label = 2;
                    case 2:
                        if (!!playerStat) return [3 /*break*/, 4];
                        playerStat = {
                            player: player,
                            wins: 0,
                            ties: 0,
                            losses: 0,
                            matchesPlayed: 0,
                            rankState: {
                                rating: this.elo.createRating()
                            }
                        };
                        if (!(!player.anonymous && this.dimension.hasDatabase())) return [3 /*break*/, 4];
                        update = {
                            statistics: user ? user.statistics : {}
                        };
                        update.statistics[this.getKeyName()] = playerStat;
                        return [4 /*yield*/, this.dimension.databasePlugin.updateUser(player.tournamentID.id, update)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        // only store locally if not in DB
                        if (!user) {
                            this.state.playerStats.set(player.tournamentID.id, playerStat);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Initialize competition with local competitors given and store player stats locally
     *
     * Does not read in any DB players
     */
    Ladder.prototype.initialize = function () {
        return __awaiter(this, void 0, void 0, function () {
            var promises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: 
                    // wait for all players to add in.
                    return [4 /*yield*/, Promise.all(this.initialAddPlayerPromises)];
                    case 1:
                        // wait for all players to add in.
                        _a.sent();
                        this.state.playerStats = new Map();
                        this.state.results = [];
                        promises = [];
                        switch (this.configs.rankSystem) {
                            case RankSystem_1.RankSystem.TRUESKILL:
                                this.competitors.forEach(function (player) {
                                    promises.push(_this.initializeTrueskillPlayerStats(player));
                                });
                                break;
                            case RankSystem_1.RankSystem.ELO:
                                this.competitors.forEach(function (player) {
                                    promises.push(_this.initializeELOPlayerStats(player));
                                });
                                break;
                        }
                        return [4 /*yield*/, Promise.all(promises)];
                    case 2:
                        _a.sent();
                        if (!this.configs.consoleDisplay) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.printTournamentStatus()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Schedules matches to play. Default function is to schedule randomly a player A with other players that are within
     * 2.5 * competitorCount rank of that player A's rank. competitorCount is the number of agents chosen to compete
     * in the particular match to schedule. See {@link Tournament.TournamentConfigs.agentsPerMatch}.
     *
     * If a {@link Ladder.Configs.matchMake | matchMake} function is provided, that will be used instead of the default.
     */
    Ladder.prototype.schedule = function () {
        return __awaiter(this, void 0, void 0, function () {
            var rankings, newMatches, sortedPlayers, newQueue;
            var _a, _b;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.getRankings(0, -1)];
                    case 1:
                        rankings = _c.sent();
                        if (this.configs.tournamentConfigs.matchMake) {
                            newMatches = this.configs.tournamentConfigs.matchMake(rankings);
                            (_a = this.matchQueue).push.apply(_a, newMatches);
                            return [2 /*return*/];
                        }
                        sortedPlayers = rankings.map(function (p) { return p.player; }).filter(function (p) { return !p.disabled; });
                        newQueue = [];
                        sortedPlayers.forEach(function (player, rank) {
                            var competitorCount = _this.selectRandomAgentAmountForMatch();
                            // take random competitors from +/- competitorCount * 2.5 ranks near you
                            var lowerBound = 0;
                            if (rank == 0)
                                lowerBound = 1;
                            if (sortedPlayers.length < competitorCount) {
                                return;
                            }
                            var randomPlayers = _this.selectRandomplayersFromArray(__spreadArrays(sortedPlayers.slice(Math.max(rank - competitorCount * 2.5, lowerBound), rank), sortedPlayers.slice(rank + 1, rank + competitorCount * 2.5)), competitorCount - 1);
                            newQueue.push(_this.shuffle(__spreadArrays([player], randomPlayers)));
                        });
                        this.shuffle(newQueue);
                        (_b = this.matchQueue).push.apply(_b, newQueue);
                        return [2 /*return*/];
                }
            });
        });
    };
    Ladder.prototype.selectRandomAgentAmountForMatch = function () {
        return this.configs.agentsPerMatch[Math.floor(Math.random() * this.configs.agentsPerMatch.length)];
    };
    // using resovoir sampling to select num distinct randomly
    Ladder.prototype.selectRandomplayersFromArray = function (arr, num, excludedSet) {
        if (excludedSet === void 0) { excludedSet = new Set(); }
        var reservoir = [];
        // put the first num into reservoir
        for (var i = 0; i < num; i++) {
            reservoir.push(arr[i]);
        }
        for (var i = num; i < arr.length; i++) {
            var j = Math.floor(Math.random() * i);
            if (j < num) {
                reservoir[j] = arr[i];
            }
        }
        return reservoir;
    };
    // when adding a new player
    Ladder.prototype.internalAddPlayer = function (player) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.configs.rankSystem;
                        switch (_a) {
                            case RankSystem_1.RankSystem.TRUESKILL: return [3 /*break*/, 1];
                            case RankSystem_1.RankSystem.ELO: return [3 /*break*/, 3];
                        }
                        return [3 /*break*/, 5];
                    case 1: return [4 /*yield*/, this.initializeTrueskillPlayerStats(player)];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, this.initializeELOPlayerStats(player)];
                    case 4:
                        _b.sent();
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    // should be called only for DB users
    Ladder.prototype.updatePlayer = function (player, oldname, oldfile) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, user, playerStat, playerStats, _b, rankSystemConfigs, currState, rankSystemConfigs, currState;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.getPlayerStat(player.tournamentID.id)];
                    case 1:
                        _a = _c.sent(), user = _a.user, playerStat = _a.playerStat;
                        playerStats = playerStat;
                        playerStats.player = player;
                        playerStats.matchesPlayed = 0;
                        playerStats.losses = 0;
                        playerStats.wins = 0;
                        playerStats.ties = 0;
                        _b = this.configs.rankSystem;
                        switch (_b) {
                            case RankSystem_1.RankSystem.ELO: return [3 /*break*/, 2];
                            case RankSystem_1.RankSystem.TRUESKILL: return [3 /*break*/, 5];
                        }
                        return [3 /*break*/, 8];
                    case 2:
                        rankSystemConfigs = this.configs.rankSystemConfigs;
                        currState = playerStats.rankState;
                        // TODO: Give user option to define how to reset score
                        currState.rating.score = rankSystemConfigs.startingScore;
                        if (!this.dimension.hasDatabase()) return [3 /*break*/, 4];
                        if (!!player.anonymous) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.updateDatabaseELOPlayerStats(playerStats, user)];
                    case 3:
                        _c.sent();
                        _c.label = 4;
                    case 4: return [3 /*break*/, 8];
                    case 5:
                        rankSystemConfigs = this.configs.rankSystemConfigs;
                        currState = playerStats.rankState;
                        // TODO: Give user option to define how to reset score
                        currState.rating = new ts_trueskill_1.Rating(currState.rating.mu, rankSystemConfigs.initialSigma);
                        if (!this.dimension.hasDatabase()) return [3 /*break*/, 7];
                        if (!!player.anonymous) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.updateDatabaseTrueskillPlayerStats(playerStats, user)];
                    case 6:
                        _c.sent();
                        _c.label = 7;
                    case 7: return [3 /*break*/, 8];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes player from tournament. Removes from state and stats from database
     * @param playerID
     */
    Ladder.prototype.internalRemovePlayer = function (playerID) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, user, playerStat, keyName, update;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getPlayerStat(playerID)];
                    case 1:
                        _a = (_b.sent()), user = _a.user, playerStat = _a.playerStat;
                        if (!playerStat) return [3 /*break*/, 4];
                        this.state.playerStats.delete(playerID);
                        this.log.info('Removed player ' + playerID);
                        if (!this.dimension.hasDatabase()) return [3 /*break*/, 3];
                        if (!user) return [3 /*break*/, 3];
                        keyName = this.getKeyName();
                        update = {
                            statistics: {}
                        };
                        // if there exists stats already, keep them
                        if (user && user.statistics) {
                            update.statistics = user.statistics;
                        }
                        // delete stats for this tournament to remove player
                        delete update.statistics[keyName];
                        return [4 /*yield*/, this.dimension.databasePlugin.updateUser(playerID, update)];
                    case 2:
                        _b.sent();
                        this.log.info('Removed player ' + playerID + ' from DB');
                        _b.label = 3;
                    case 3: return [3 /*break*/, 5];
                    case 4: throw new DimensionError_1.TournamentPlayerDoesNotExistError("Could not find player with ID: " + playerID);
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Print tournament status to display
     */
    Ladder.prototype.printTournamentStatus = function () {
        return __awaiter(this, void 0, void 0, function () {
            var ranks;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.log.level > Logger_1.Logger.LEVEL.NONE)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getRankings(0, -1)];
                    case 1:
                        ranks = _a.sent();
                        console.clear();
                        console.log(this.log.bar());
                        console.log("Tournament - ID: " + this.id + ", Name: " + this.name + " | Dimension - ID: " + this.dimension.id + ", Name: " + this.dimension.name + "\nStatus: " + this.status + " | Competitors: " + this.competitors.size + " | Rank System: " + this.configs.rankSystem + "\n");
                        console.log('Total Matches: ' + this.state.statistics.totalMatches + ' | Matches Queued: ' + this.matchQueue.length);
                        switch (this.configs.rankSystem) {
                            case RankSystem_1.RankSystem.TRUESKILL:
                                console.log(sprintf_js_1.sprintf("%-30s | %-14s | %-15s | %-18s | %-8s".underline, 'Name', 'ID', 'Score=(μ - 3σ)', 'Mu: μ, Sigma: σ', 'Matches'));
                                ranks.forEach(function (info) {
                                    console.log(sprintf_js_1.sprintf("%-30s".blue + " | %-14s | " + "%-15s".green + " | " + "\u03BC=%-6s, \u03C3=%-6s".yellow + " | %-8s", info.player.tournamentID.name + (info.player.disabled ? ' X' : ''), info.player.tournamentID.id, (info.rankState.rating.mu - info.rankState.rating.sigma * 3).toFixed(7), info.rankState.rating.mu.toFixed(3), info.rankState.rating.sigma.toFixed(3), info.matchesPlayed));
                                });
                                break;
                            case RankSystem_1.RankSystem.ELO:
                                console.log(sprintf_js_1.sprintf("%-30s | %-8s | %-15s | %-8s".underline, 'Name', 'ID', 'ELO Score', 'Matches'));
                                ranks.forEach(function (info) {
                                    console.log(sprintf_js_1.sprintf("%-30s".blue + " | %-8s | " + "%-15s".green + " | %-8s", info.player.tournamentID.name, info.player.tournamentID.id, info.rankState.rating.score, info.matchesPlayed));
                                });
                                break;
                        }
                        console.log();
                        console.log('Current Matches: ' + (this.matches.size));
                        this.matches.forEach(function (match) {
                            var names = [];
                            match.agents.forEach(function (agent) {
                                names.push(agent.name);
                            });
                            console.log(names);
                        });
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Checks whether match can still be run
     */
    Ladder.prototype.checkMatchIntegrity = function (matchInfo) {
        return __awaiter(this, void 0, void 0, function () {
            var checkIntegrity, promises, i, player;
            var _this = this;
            return __generator(this, function (_a) {
                checkIntegrity = function (id) { return __awaiter(_this, void 0, void 0, function () {
                    var stat;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.getPlayerStat(id)];
                            case 1:
                                stat = _a.sent();
                                if (!stat.playerStat) {
                                    return [2 /*return*/, false];
                                }
                                else if (stat.playerStat.player.disabled) {
                                    return [2 /*return*/, false];
                                }
                                return [2 /*return*/, true];
                        }
                    });
                }); };
                promises = [];
                for (i = 0; i < matchInfo.length; i++) {
                    player = matchInfo[i];
                    promises.push(checkIntegrity(player.tournamentID.id));
                }
                return [2 /*return*/, Promise.all(promises).then(function (integritys) {
                        for (var i = 0; i < integritys.length; i++) {
                            if (integritys[i] === false)
                                return false;
                        }
                        return true;
                    })];
            });
        });
    };
    /**
     * Handles the start and end of a match, and updates state accrding to match results and the given result handler
     * @param matchInfo
     */
    Ladder.prototype.handleMatch = function (matchInfo) {
        return __awaiter(this, void 0, void 0, function () {
            var matchRes, tournamentID, tournamentID, resInfo;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.checkMatchIntegrity(matchInfo)];
                    case 1:
                        if (!(_a.sent())) {
                            // quit
                            this.log.detail('Match queued cannot be run anymore');
                            return [2 /*return*/];
                        }
                        if (!this.configs.consoleDisplay) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.printTournamentStatus()];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        this.log.detail('Running match - Competitors: ', matchInfo.map(function (player) { return player.tournamentID.name; }));
                        return [4 /*yield*/, this.runMatch(matchInfo)];
                    case 4:
                        matchRes = _a.sent();
                        if (!matchRes.err) return [3 /*break*/, 10];
                        if (!(matchRes.err instanceof DimensionError_1.AgentCompileError)) return [3 /*break*/, 6];
                        tournamentID = matchRes.match.mapAgentIDtoTournamentID.get(matchRes.err.agentID);
                        this.log.warn("Match couldn't run. Player " + tournamentID.id + " got a compile error");
                        return [4 /*yield*/, this.disablePlayer(tournamentID.id)];
                    case 5:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 6:
                        if (!(matchRes.err instanceof DimensionError_1.AgentInstallError)) return [3 /*break*/, 8];
                        tournamentID = matchRes.match.mapAgentIDtoTournamentID.get(matchRes.err.agentID);
                        this.log.warn("Match couldn't run. Player " + tournamentID.id + " got an install error");
                        return [4 /*yield*/, this.disablePlayer(tournamentID.id)];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 8:
                        this.log.error("Match couldn't run, aborting... ", matchRes.err);
                        _a.label = 9;
                    case 9:
                        // remove the match from the active matches list
                        this.matches.delete(matchRes.match.id);
                        return [2 /*return*/];
                    case 10:
                        // update total matches
                        this.state.statistics.totalMatches++;
                        resInfo = this.configs.resultHandler(matchRes.results);
                        switch (this.configs.rankSystem) {
                            case RankSystem_1.RankSystem.TRUESKILL:
                                // push to result processing queue
                                this.resultProcessingQueue.push({ result: resInfo, mapAgentIDtoTournamentID: matchRes.match.mapAgentIDtoTournamentID });
                                // make a call to handle match with trueskill to process the next result in the processing queue
                                this.handleMatchWithTrueSkill();
                                break;
                            case RankSystem_1.RankSystem.ELO:
                                // push to result processing queue
                                this.resultProcessingQueue.push({ result: resInfo, mapAgentIDtoTournamentID: matchRes.match.mapAgentIDtoTournamentID });
                                this.handleMatchWithELO();
                                break;
                        }
                        // store past results
                        if (this.configs.tournamentConfigs.storePastResults) {
                            if (!(this.dimension.hasDatabase() && this.dimension.databasePlugin.configs.saveTournamentMatches)) {
                                // if we have don't have a database that is set to actively store tournament matches we store locally
                                this.state.results.push(matchRes.results);
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Update player stats for whoever stats owns this. Determined by checking the player field of
     * {@link Ladder.PlayerStat}
     */
    Ladder.prototype.updatePlayerStat = function (currentStats) {
        return __awaiter(this, void 0, void 0, function () {
            var user, err_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!currentStats.player.anonymous) return [3 /*break*/, 1];
                        this.state.playerStats.set(currentStats.player.tournamentID.id, currentStats);
                        return [3 /*break*/, 5];
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.dimension.databasePlugin.getUser(currentStats.player.tournamentID.id)
                            // if user is still in tourney, update it
                        ];
                    case 2:
                        user = _a.sent();
                        // if user is still in tourney, update it
                        if (user && user.statistics[this.getKeyName()]) {
                            switch (this.configs.rankSystem) {
                                case RankSystem_1.RankSystem.TRUESKILL:
                                    this.updateDatabaseTrueskillPlayerStats(currentStats, user);
                                    break;
                                case RankSystem_1.RankSystem.ELO:
                                    this.updateDatabaseELOPlayerStats(currentStats, user);
                                    break;
                            }
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        err_3 = _a.sent();
                        // don't stop tourney if this happens
                        this.log.error("Issue with using database", err_3);
                        return [3 /*break*/, 4];
                    case 4:
                        ;
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Handles match results.
     *
     * If match result is {ranks: []}, nothing will happen, can be used to mark a match as having errored
     */
    Ladder.prototype.handleMatchWithTrueSkill = function () {
        return __awaiter(this, void 0, void 0, function () {
            var toProcess, mapAgentIDtoTournamentID, result, playerRatings, tourneyIDs, ranks, fetchingRatings, err_4, newRatings, updatePlayerStatsPromises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        toProcess = this.resultProcessingQueue.shift();
                        mapAgentIDtoTournamentID = toProcess.mapAgentIDtoTournamentID;
                        result = toProcess.result;
                        // stop if no ranks provided, meaning match not successful and we throw result away
                        if (result.ranks.length === 0)
                            return [2 /*return*/];
                        playerRatings = [];
                        tourneyIDs = [];
                        ranks = [];
                        result.ranks.sort(function (a, b) { return a.rank - b.rank; });
                        fetchingRatings = [];
                        result.ranks.forEach(function (rank) {
                            var fetchRating = function () { return __awaiter(_this, void 0, void 0, function () {
                                var tournamentID, playerStat, currentplayerStats, currRankState;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            tournamentID = mapAgentIDtoTournamentID.get(rank.agentID);
                                            return [4 /*yield*/, this.getPlayerStat(tournamentID.id)];
                                        case 1:
                                            playerStat = (_a.sent()).playerStat;
                                            if (!playerStat) {
                                                throw new DimensionError_1.TournamentPlayerDoesNotExistError("Player " + tournamentID.id + " doesn't exist anymore, likely was removed");
                                            }
                                            currentplayerStats = playerStat;
                                            currentplayerStats.matchesPlayed++;
                                            currRankState = currentplayerStats.rankState;
                                            playerRatings.push([currRankState.rating]);
                                            ranks.push(rank.rank);
                                            tourneyIDs.push({ id: tournamentID, stats: currentplayerStats });
                                            return [2 /*return*/];
                                    }
                                });
                            }); };
                            fetchingRatings.push(fetchRating());
                        });
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, Promise.all(fetchingRatings)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_4 = _a.sent();
                        this.log.error('Probably due to player being removed: ', err_4);
                        return [2 /*return*/];
                    case 4:
                        newRatings = ts_trueskill_1.rate(playerRatings, ranks);
                        updatePlayerStatsPromises = [];
                        tourneyIDs.forEach(function (info, i) {
                            var updateStat = function () { return __awaiter(_this, void 0, void 0, function () {
                                var currentStats;
                                return __generator(this, function (_a) {
                                    currentStats = info.stats;
                                    currentStats.rankState.rating = newRatings[i][0];
                                    this.updatePlayerStat(currentStats);
                                    return [2 /*return*/];
                                });
                            }); };
                            updatePlayerStatsPromises.push(updateStat());
                        });
                        return [4 /*yield*/, Promise.all(updatePlayerStatsPromises)];
                    case 5:
                        _a.sent();
                        if (!this.configs.consoleDisplay) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.printTournamentStatus()];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    Ladder.prototype.handleMatchWithELO = function () {
        return __awaiter(this, void 0, void 0, function () {
            var toProcess, mapAgentIDtoTournamentID, result, ratingsToChange, ranks, tourneyIDs, fetchingRatings, err_5, updatePlayerStatsPromises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        toProcess = this.resultProcessingQueue.shift();
                        mapAgentIDtoTournamentID = toProcess.mapAgentIDtoTournamentID;
                        result = toProcess.result;
                        if (result.ranks.length === 0)
                            return [2 /*return*/];
                        ratingsToChange = [];
                        ranks = [];
                        tourneyIDs = [];
                        fetchingRatings = [];
                        result.ranks.forEach(function (rankInfo) {
                            var fetchRating = function () { return __awaiter(_this, void 0, void 0, function () {
                                var tournamentID, playerStat, currentplayerStats, currRankState;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            tournamentID = mapAgentIDtoTournamentID.get(rankInfo.agentID);
                                            return [4 /*yield*/, this.getPlayerStat(tournamentID.id)];
                                        case 1:
                                            playerStat = (_a.sent()).playerStat;
                                            if (!playerStat) {
                                                throw new DimensionError_1.TournamentPlayerDoesNotExistError("Player " + tournamentID.id + " doesn't exist anymore, likely was removed");
                                            }
                                            currentplayerStats = playerStat;
                                            currentplayerStats.matchesPlayed++;
                                            currRankState = currentplayerStats.rankState;
                                            ratingsToChange.push(currRankState.rating);
                                            ranks.push(rankInfo.rank);
                                            tourneyIDs.push({ id: tournamentID, stats: currentplayerStats });
                                            return [2 /*return*/];
                                    }
                                });
                            }); };
                            fetchingRatings.push(fetchRating());
                        });
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, Promise.all(fetchingRatings)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_5 = _a.sent();
                        this.log.error('Probably due to player being removed: ', err_5);
                        return [2 /*return*/];
                    case 4:
                        // re adjust rankings
                        this.elo.rate(ratingsToChange, ranks);
                        updatePlayerStatsPromises = [];
                        // update database if needed and store play stats
                        tourneyIDs.forEach(function (info) {
                            var updateStat = function () { return __awaiter(_this, void 0, void 0, function () {
                                var currentStats;
                                return __generator(this, function (_a) {
                                    currentStats = info.stats;
                                    updatePlayerStatsPromises.push(this.updatePlayerStat(currentStats));
                                    return [2 /*return*/];
                                });
                            }); };
                            updatePlayerStatsPromises.push(updateStat());
                        });
                        return [4 /*yield*/, Promise.all(updatePlayerStatsPromises)];
                    case 5:
                        _a.sent();
                        if (!this.configs.consoleDisplay) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.printTournamentStatus()];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    Ladder.prototype.preInternalDestroy = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.runInterval)
                    clearInterval(this.runInterval);
                if (this.configSyncInterval)
                    clearInterval(this.configSyncInterval);
                return [2 /*return*/];
            });
        });
    };
    return Ladder;
}(__1.Tournament));
exports.Ladder = Ladder;
//# sourceMappingURL=index.js.map