import { Tournament, Player } from "..";
import { DeepPartial } from "../../utils/DeepPartial";
import { Design } from '../../Design';
import { Dimension, NanoID } from "../../Dimension";
/**
 * The Round Robin Tournament Class
 *
 * Only supports two agent matches at the moment and is meant for single instance use only
 */
export declare class RoundRobin extends Tournament {
    configs: Tournament.TournamentConfigs<Tournament.RoundRobin.Configs>;
    private shouldStop;
    private resumePromise;
    private resumeResolver;
    private resolveStopPromise;
    state: Tournament.RoundRobin.State;
    constructor(design: Design, files: Array<string> | Array<{
        file: string;
        name: string;
    }>, tournamentConfigs: Tournament.TournamentConfigsBase, id: NanoID, dimension: Dimension);
    /**
     * Runs a round robin to completion. Resolves with the {@link RoundRobin.State} once the tournament is finished
     * @param configs - the configs to use for this run
     */
    run(configs?: DeepPartial<Tournament.TournamentConfigs<Tournament.RoundRobin.Configs>>): Promise<Tournament.RoundRobin.State>;
    /**
     * Handles the start and end of a match, and updates state accrding to match results and the given result handler
     * @param matchInfo
     */
    private handleMatch;
    /**
     * Stops the tournament
     */
    stop(): Promise<void>;
    /**
     * Resumes the tournament
     */
    resume(): Promise<void>;
    /**
     * Returns the current rankings
     */
    getRankings(): any[];
    /**
     * Gets the current configs
     */
    getConfigs(): Tournament.TournamentConfigs<Tournament.RoundRobin.Configs>;
    /**
     * Sets the configs
     * @param configs - configs to use
     */
    setConfigs(configs?: DeepPartial<Tournament.TournamentConfigs<Tournament.RoundRobin.Configs>>): void;
    private initialize;
    /**
     * Queue up all matches necessary
     */
    private schedule;
    private generateARound;
    internalAddPlayer(player: Player): void;
    updatePlayer(player: Player, oldname: string, oldfile: string): Promise<void>;
    private printTournamentStatus;
}
/**
 * The RoundRobin Tournament namespace
 */
export declare namespace RoundRobin {
    /**
     * Configuration interface for {@link RoundRobinTournament}
     */
    interface Configs extends Tournament.TournamentTypeConfig {
        /**
         * Number of times each player competes against another player
         * @default `2`
         */
        times: number;
    }
    /**
     * The {@link RoundRobinTournament} state, consisting of the current player statistics and past results
     */
    interface State extends Tournament.TournamentTypeState {
        /**
         * A map from a {@link Player} Tournament ID string to statistics
         */
        playerStats: Map<string, {
            player: Player;
            wins: number;
            ties: number;
            losses: number;
            matchesPlayed: number;
        }>;
        /**
         * Stats for this Tournament in this instance. Intended to be constant memory usage
         */
        statistics: {
            totalMatches: number;
        };
    }
}
