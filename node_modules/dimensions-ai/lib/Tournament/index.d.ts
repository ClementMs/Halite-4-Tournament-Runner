import { Match } from '../Match';
import { Design } from '../Design';
import { DeepPartial } from '../utils/DeepPartial';
import { Logger } from '../Logger';
import RankSystemDefault = require('./RankSystem');
import { Dimension, NanoID } from '../Dimension';
import TournamentStatusDefault = require('./TournamentStatus');
import TournamentTypeDefault = require('./TournamentTypes');
/** @ignore */
import _RankSystem = RankSystemDefault.RankSystem;
/** @ignore */
import _TOURNAMENT_TYPE = TournamentTypeDefault.TournamentType;
/** @ignore */
import _TournamentStatus = TournamentStatusDefault.TournamentStatus;
/**
 * Player class that persists data for the same ephemereal agent across multiple matches
 */
export declare class Player {
    tournamentID: Tournament.ID;
    file: string;
    /**
     * Whether this player is anonymous and not tied to a user on the back end
     *
     * If this is ever false, then that means 1. we have a backend setup 2. there is an actual user entry
     */
    anonymous: boolean;
    /** Associated username if there is one */
    username: string;
    /**
     * Path to player's directory, not the file to be executed/used
     */
    botDirPath: string;
    /**
     * Key that references the player's bot file object if it exists
     */
    botkey: string;
    /**
     * Whether or not this player is disabled and won't be used in in the default match scheduling for
     * {@link Tournament.Ladder | Ladder Tournaments}. Is set to true if this player's bot throws an error during
     * the initialization stage of a {@link Match}.
     */
    disabled: boolean;
    /**
     * Path to the zip file for the bot
     */
    zipFile: string;
    constructor(tournamentID: Tournament.ID, file: string, zipFile: string, botkey?: string);
    /**
     * Generates a 12 character player id string
     */
    static generatePlayerID(): string;
}
/**
 * The tournament class and module extended by all concrete Tournament Classes. Tournament Types available now are
 * {@link RoundRobin}, {@link Ladder}, {@link Elimination}. A tournament is composed of players, which can either be
 * all locally stored, or a split between locally stored anonymous players and database stored user owned players.
 * Ladder is the only tournament where it can be made distributed, other tournament types may only be run as a single
 * instance
 *
 * Notes: `this.competitors` map is used when no DB is used. When a DB is used, locally stored players are only in
 * `this.anonymousCompetitors` and other players are pulled from DB. Hence, a lot of code requires checking if database
 * exists and if so, pull from there and the anonymous competitors map, other wise use this.state or this.competitors
 */
export declare abstract class Tournament {
    protected design: Design;
    /** Tournament configs */
    abstract configs: Tournament.TournamentConfigsBase;
    /** Mapping match ids to active ongoing matches */
    matches: Map<NanoID, Match>;
    /** A queue whose elements are each arrays of players that are to compete against each other */
    matchQueue: Array<Array<Player>>;
    /** The current status of the tournament */
    status: Tournament.Status;
    /** Ongoing tournament state. Type dependent on Tournament Type chosen */
    abstract state: Tournament.TournamentTypeState;
    /** Logger */
    log: Logger;
    /** Registered competitors in this tournament */
    competitors: Map<NanoID, Player>;
    /** All competitors that are anonymous competitors and not registered in database */
    anonymousCompetitors: Map<NanoID, Player>;
    private playerID;
    /** A reference to the dimension this tournament was spawned from */
    dimension: Dimension;
    /** This tournament's ID */
    id: NanoID;
    /**
     * This Tournament's name
     */
    name: string;
    /**
     * Promise array of which all resolves once every player added through constructor is finished adding
     */
    initialAddPlayerPromises: Array<Promise<any>>;
    constructor(design: Design, files: Array<string> | Array<{
        file: string;
        name: string;
    }>, id: NanoID, tournamentConfigs: Tournament.TournamentConfigsBase, dimension: Dimension);
    /**
     * Add a player to the tournament. Can specify an ID to use. If that ID exists already, this will update the file for
     * that player instead. First time a player is added (doesn't exist in competitors map yet), if there is existing
     * stats they won't be reset. Subsequent adds will change the stats.
     *
     * If the player is to exist beyond the tournament, an existingID must always be provided and generated somewhere else
     *
     * Resolves with the new player or updated player
     *
     * @param file - The file to the bot or an object with the file and a name for the player specified
     * @param existingID - The optional id of the player
     *
     */
    addplayer(file: string | {
        file: string;
        name: string;
        zipFile?: string;
        botdir?: string;
        botkey?: string;
    }, existingID?: NanoID): Promise<Player>;
    /**
     * Function to be implemented by a tournament type that performs further tasks to integrate a new player
     * @param player
     */
    abstract internalAddPlayer(player: Player): void;
    /**
     * Returns a new id for identifying a player in a tournament
     * Only used when adding a plyaer to a tournament is done without specifying an id to use.
     */
    generateNextTournamentIDString(): string;
    /**
     * Start the tournament
     * @param configs - the configs to use for the tournament
     * @param master - whether or not the instance calling stop was the first one, the "master" instance. Used only in
     * distributed scenarios
     */
    abstract run(configs?: DeepPartial<Tournament.TournamentConfigsBase>, master?: boolean): Promise<any>;
    /**
     * Stops the tournament while running
     * @param master - whether or not the instance calling stop was the first one, the "master" instance. Used only in
     * distributed scenarios
     */
    abstract stop(master?: boolean): Promise<any>;
    /**
     * Resumes the tournament
     * @param master - whether or not the instance calling stop was the first one, the "master" instance. Used only in
     * distributed scenarios
     */
    abstract resume(master?: boolean): Promise<any>;
    /**
     * Retrieve some form of rankings from the tournament's current state. The params offset and limit only apply to
     * {@link Tournament.Ladder | Ladder Tournaments}, used for scaling purposes.
     *
     * @param offset - the starting ranking to retrieve from
     * @param limit - the number of rankings to retrieve
     */
    abstract getRankings(offset?: number, limit?: number): any;
    /**
     * Update function that is called whenever an existing player is updated
     * @param player - the {@link Player} that was updated
     * @param oldname - the previous name for the player
     * @param oldfile - the previous file for the player
     */
    abstract updatePlayer(player: Player, oldname: string, oldfile: string): Promise<void>;
    /**
     * Disables the player with id playerID
     * @param playerID - the player's id to disable
     */
    disablePlayer(playerID: nanoid): Promise<void>;
    /**
     * Removes the competitor/player with id `playerID` (a {@link nanoid}). Resolves if succesful, otherwise rejects if
     * player doesn't exist or couldn't be removed
     *
     * @param playerID - ID of the player to remove
     */
    removePlayer(playerID: nanoid): Promise<void>;
    protected internalRemovePlayer(playerID: nanoid): Promise<void>;
    /**
     * Set configs for this tournament
     * @param configs the configs to deep merge with the current configs
     */
    abstract setConfigs(configs: DeepPartial<Tournament.TournamentConfigsBase>): void;
    /**
     * Set configs for this tournament
     * @param configs the configs to deep merge with the current configs
     */
    abstract getConfigs(): Tournament.TournamentConfigsBase;
    /**
     * Runs a match
     * @param players - the players to compete together
     * @returns a promise that resolves with the results and the associated match
     */
    protected runMatch(players: Array<Player>): Promise<{
        results: any;
        match: Match;
        err?: any;
    }>;
    /**
     * Removes a match by id. Returns true if deleted, false if nothing was deleted
     */
    removeMatch(matchID: NanoID): Promise<boolean>;
    /**
     * Destroy this tournament. Rejects if an error occured in trying to destroy it.
     */
    destroy(): Promise<void>;
    /**
     * Pre run function before generic destroy takes place
     */
    protected preInternalDestroy(): Promise<void>;
    /**
     * Post run function before generic destroy takes place
     */
    protected postInternalDestroy(): Promise<void>;
    /**
     * Generates a 6 character tournament ID identifying this tournament class instance. Not to be confused with
     * {@link Tournament.ID} which is the ID for competitors in the tournament
     */
    static genTournamentClassID(): string;
    /**
     * Returns the name of the tournament but formatted (no spaces)
     */
    getSafeName(): string;
    /**
     * Returns a key name to be used when storing a tournament by a combination of its name and id
     */
    getKeyName(): string;
    /**
     * Resolves with player stats if player with the id exists. Includes database user if db contains the player
     * Fields are null if they don't exist. If playerStat field is null, then this player does not exist
     *
     * @param id - id of player to get
     */
    getPlayerStat(id: nanoid): Promise<{
        user: Database.User;
        playerStat: Tournament.PlayerStatBase;
    }>;
}
import LadderDefault = require('./Ladder');
/** @ignore */
import LadderTournament = LadderDefault.Ladder;
import RoundRobinDefault = require('./RoundRobin');
/** @ignore */
import RoundRobinTournament = RoundRobinDefault.RoundRobin;
import EliminationDefault = require('./Elimination');
/** @ignore */
import EliminationTournament = EliminationDefault.Elimination;
import { nanoid } from '..';
import { Database } from '../Plugin/Database';
export declare module Tournament {
    export import Type = _TOURNAMENT_TYPE;
    export import Status = _TournamentStatus;
    export import RankSystem = _RankSystem;
    /**
     * @deprecated since v2.1.0
     *
     * Use {@link Tournament.RankSystem} instead
     */
    export import RANK_SYSTEM = _RankSystem;
    /**
     * @deprecated since v2.1.0
     *
     * Use {@link Tournament.Type} instead.
     */
    export import TOURNAMENT_TYPE = _TOURNAMENT_TYPE;
    /**
     * @deprecated since v2.1.0
     *
     * Use {@link Tournament.Status} instead.
     */
    export import TournamentStatus = _TournamentStatus;
    /**
     * Required and Optional Tournament configurations
     */
    interface TournamentConfigsBase {
        /**
         * The default match configurations to be applied throughout all tournament matches
         */
        defaultMatchConfigs?: DeepPartial<Match.Configs>;
        /**
         * The tournament type to run. See {@link Tournament.Type}
         */
        type: Type;
        /**
         * The ranking system to use for this tournament
         */
        rankSystem: RankSystem;
        /**
         * The result handler for returning the appropriate results to the tournament for processing.
         *
         * To find what kind of result should be returned, find the Results interface for the rank system you are using.
         *
         * Example: For {@link Tournament.RankSystem.TRUESKILL}, go to {@link Tournament.RankSystem.TRUESKILL.Results}
         */
        resultHandler: 
        /**
         * @param results - the results received from calling the {@link Design.getResults} function
         */
        (results: any) => any;
        /**
         * The configurations for a specified rank system. For example, see {@link RankSystem.WINS.Configs},
         * {@link RankSystem.TRUESKILL.Configs}
         */
        rankSystemConfigs?: any;
        /**
         * The tournament wide logging level to enforce
         */
        loggingLevel?: Logger.LEVEL;
        /**
         * The name of the tournament
         */
        name?: string;
        /**
         * Tournament configurations. Dependent on the type of tournament chosen
         * Example: For {@link RoundRobin}, go to {@link RoundRobin.Configs}
         */
        tournamentConfigs?: any;
        /**
         * An array of valid number of players that can compete in a match. For Rock Paper Scissors for example this would
         * be [2]
         * @default `[2]`
         */
        agentsPerMatch: Array<number>;
        /**
         * Whether or not to display a continuous console log of the current tournament as it runs
         * @default `true`
         */
        consoleDisplay?: boolean;
        /**
         * Set this ID to override the generated ID
         */
        id?: string;
    }
    /**
     * Queued match information, consisting of player IDs of players to compete
     */
    type QueuedMatchInfo = Array<nanoid>;
    /**
     * Internally used type.
     */
    interface TournamentConfigs<ConfigType> extends TournamentConfigsBase {
        tournamentConfigs: ConfigType;
        rankSystemConfigs: any;
    }
    interface TournamentTypeConfig {
        /**
         * Whether or not to store past results using the specified option of the dimension (database or in memory)
         * @default `true`
         */
        storePastResults: boolean;
    }
    interface TournamentTypeState {
        /**
         * Past results stored. Each element is what is returned by {@link Design.getResults}
         */
        results: Array<any>;
        /**
         * Map from player ID to player stats
         */
        playerStats: Map<NanoID, PlayerStatBase>;
    }
    /**
     * Tournament.ID. Represents an identifier for players competing in a {@link Tournament}
     */
    interface ID {
        /** A string id. This should never change */
        readonly id: NanoID;
        /** A display name */
        name: string;
        /** Associated username if there is one. */
        username: string;
    }
    interface PlayerStatBase {
        player: Player;
        matchesPlayed: number;
    }
    export import Ladder = LadderTournament;
    export import RoundRobin = RoundRobinTournament;
    export import Elimination = EliminationTournament;
}
