/// <reference types="node" />
/**
 * API for dimension's matches
 */
import express from 'express';
import { Match } from '../../../../../Match';
declare const router: import("express-serve-static-core").Router;
/**
 * Get match by matchID. Requires a tournament or dimension to be stored.
 *
 * For tournaments, it will get a match only if it's active. Otherwise a database plugin is needed in order to retrieve
 * the match. NOTE that the database plugin will not recover all of the same match data as usually returned from active
 * matches
 *
 * For dimension run match (via {@link Dimension.runMatch}), it is retrievable as long as it has not been destroyed
 */
export declare const getMatch: (req: express.Request<import("express-serve-static-core").ParamsDictionary>, res: express.Response<any>, next: express.NextFunction) => Promise<void>;
/**
 * Pick relevant fields of a match
 */
export declare const pickMatch: (match: Match) => {
    creationDate?: {
        toString?: () => string;
        toDateString?: () => string;
        toTimeString?: () => string;
        toLocaleString?: {
            (): string;
            (locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;
        };
        toLocaleDateString?: {
            (): string;
            (locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;
        };
        toLocaleTimeString?: {
            (): string;
            (locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;
        };
        valueOf?: () => number;
        getTime?: () => number;
        getFullYear?: () => number;
        getUTCFullYear?: () => number;
        getMonth?: () => number;
        getUTCMonth?: () => number;
        getDate?: () => number;
        getUTCDate?: () => number;
        getDay?: () => number;
        getUTCDay?: () => number;
        getHours?: () => number;
        getUTCHours?: () => number;
        getMinutes?: () => number;
        getUTCMinutes?: () => number;
        getSeconds?: () => number;
        getUTCSeconds?: () => number;
        getMilliseconds?: () => number;
        getUTCMilliseconds?: () => number;
        getTimezoneOffset?: () => number;
        setTime?: (time: number) => number;
        setMilliseconds?: (ms: number) => number;
        setUTCMilliseconds?: (ms: number) => number;
        setSeconds?: (sec: number, ms?: number) => number;
        setUTCSeconds?: (sec: number, ms?: number) => number;
        setMinutes?: (min: number, sec?: number, ms?: number) => number;
        setUTCMinutes?: (min: number, sec?: number, ms?: number) => number;
        setHours?: (hours: number, min?: number, sec?: number, ms?: number) => number;
        setUTCHours?: (hours: number, min?: number, sec?: number, ms?: number) => number;
        setDate?: (date: number) => number;
        setUTCDate?: (date: number) => number;
        setMonth?: (month: number, date?: number) => number;
        setUTCMonth?: (month: number, date?: number) => number;
        setFullYear?: (year: number, month?: number, date?: number) => number;
        setUTCFullYear?: (year: number, month?: number, date?: number) => number;
        toUTCString?: () => string;
        toISOString?: () => string;
        toJSON?: (key?: any) => string;
        getVarDate?: () => VarDate;
    };
    finishDate?: {
        toString?: () => string;
        toDateString?: () => string;
        toTimeString?: () => string;
        toLocaleString?: {
            (): string;
            (locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;
        };
        toLocaleDateString?: {
            (): string;
            (locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;
        };
        toLocaleTimeString?: {
            (): string;
            (locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;
        };
        valueOf?: () => number;
        getTime?: () => number;
        getFullYear?: () => number;
        getUTCFullYear?: () => number;
        getMonth?: () => number;
        getUTCMonth?: () => number;
        getDate?: () => number;
        getUTCDate?: () => number;
        getDay?: () => number;
        getUTCDay?: () => number;
        getHours?: () => number;
        getUTCHours?: () => number;
        getMinutes?: () => number;
        getUTCMinutes?: () => number;
        getSeconds?: () => number;
        getUTCSeconds?: () => number;
        getMilliseconds?: () => number;
        getUTCMilliseconds?: () => number;
        getTimezoneOffset?: () => number;
        setTime?: (time: number) => number;
        setMilliseconds?: (ms: number) => number;
        setUTCMilliseconds?: (ms: number) => number;
        setSeconds?: (sec: number, ms?: number) => number;
        setUTCSeconds?: (sec: number, ms?: number) => number;
        setMinutes?: (min: number, sec?: number, ms?: number) => number;
        setUTCMinutes?: (min: number, sec?: number, ms?: number) => number;
        setHours?: (hours: number, min?: number, sec?: number, ms?: number) => number;
        setUTCHours?: (hours: number, min?: number, sec?: number, ms?: number) => number;
        setDate?: (date: number) => number;
        setUTCDate?: (date: number) => number;
        setMonth?: (month: number, date?: number) => number;
        setUTCMonth?: (month: number, date?: number) => number;
        setFullYear?: (year: number, month?: number, date?: number) => number;
        setUTCFullYear?: (year: number, month?: number, date?: number) => number;
        toUTCString?: () => string;
        toISOString?: () => string;
        toJSON?: (key?: any) => string;
        getVarDate?: () => VarDate;
    };
    name?: string;
    id?: string;
    state?: any;
    agents?: {
        id?: number;
        tournamentID?: {
            readonly id?: string;
            name?: string;
            username?: string;
        };
        name?: string;
        src?: string;
        ext?: string;
        srcNoExt?: string;
        cwd?: string;
        cmd?: string;
        file?: string;
        options?: {
            name?: string;
            secureMode?: boolean;
            id?: number;
            tournamentID?: {
                readonly id?: string;
                name?: string;
                username?: string;
            };
            loggingLevel?: import("../../../../..").Logger.LEVEL;
            maxInstallTime?: number;
            maxCompileTime?: number;
            compileCommands?: {
                [x: string]: string[];
            };
            runCommands?: {
                [x: string]: string[];
            };
        };
        creationDate?: {
            toString?: () => string;
            toDateString?: () => string;
            toTimeString?: () => string;
            toLocaleString?: {
                (): string;
                (locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;
            };
            toLocaleDateString?: {
                (): string;
                (locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;
            };
            toLocaleTimeString?: {
                (): string;
                (locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;
            };
            valueOf?: () => number;
            getTime?: () => number;
            getFullYear?: () => number;
            getUTCFullYear?: () => number;
            getMonth?: () => number;
            getUTCMonth?: () => number;
            getDate?: () => number;
            getUTCDate?: () => number;
            getDay?: () => number;
            getUTCDay?: () => number;
            getHours?: () => number;
            getUTCHours?: () => number;
            getMinutes?: () => number;
            getUTCMinutes?: () => number;
            getSeconds?: () => number;
            getUTCSeconds?: () => number;
            getMilliseconds?: () => number;
            getUTCMilliseconds?: () => number;
            getTimezoneOffset?: () => number;
            setTime?: (time: number) => number;
            setMilliseconds?: (ms: number) => number;
            setUTCMilliseconds?: (ms: number) => number;
            setSeconds?: (sec: number, ms?: number) => number;
            setUTCSeconds?: (sec: number, ms?: number) => number;
            setMinutes?: (min: number, sec?: number, ms?: number) => number;
            setUTCMinutes?: (min: number, sec?: number, ms?: number) => number;
            setHours?: (hours: number, min?: number, sec?: number, ms?: number) => number;
            setUTCHours?: (hours: number, min?: number, sec?: number, ms?: number) => number;
            setDate?: (date: number) => number;
            setUTCDate?: (date: number) => number;
            setMonth?: (month: number, date?: number) => number;
            setUTCMonth?: (month: number, date?: number) => number;
            setFullYear?: (year: number, month?: number, date?: number) => number;
            setUTCFullYear?: (year: number, month?: number, date?: number) => number;
            toUTCString?: () => string;
            toISOString?: () => string;
            toJSON?: (key?: any) => string;
            getVarDate?: () => VarDate;
        };
        _buffer?: string[];
        memoryWatchInterval?: any;
        process?: {
            stdin?: {
                readonly writable?: boolean;
                readonly writableEnded?: boolean;
                readonly writableFinished?: boolean;
                readonly writableHighWaterMark?: number;
                readonly writableLength?: number;
                readonly writableObjectMode?: boolean;
                destroyed?: boolean;
                _write?: (chunk: any, encoding: string, callback: (error?: Error) => void) => void;
                _writev?: (chunks: {
                    chunk: any;
                    encoding: string;
                }[], callback: (error?: Error) => void) => void;
                _destroy?: (error: Error, callback: (error?: Error) => void) => void;
                _final?: (callback: (error?: Error) => void) => void;
                write?: {
                    (chunk: any, cb?: (error: Error) => void): boolean;
                    (chunk: any, encoding: string, cb?: (error: Error) => void): boolean;
                };
                setDefaultEncoding?: (encoding: string) => import("stream").Writable;
                end?: {
                    (cb?: () => void): void;
                    (chunk: any, cb?: () => void): void;
                    (chunk: any, encoding: string, cb?: () => void): void;
                };
                cork?: () => void;
                uncork?: () => void;
                destroy?: (error?: Error) => void;
                addListener?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                emit?: {
                    (event: "close"): boolean;
                    (event: "drain"): boolean;
                    (event: "error", err: Error): boolean;
                    (event: "finish"): boolean;
                    (event: "pipe", src: import("stream").Readable): boolean;
                    (event: "unpipe", src: import("stream").Readable): boolean;
                    (event: string | symbol, ...args: any[]): boolean;
                };
                on?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                once?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                prependListener?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                prependOnceListener?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                removeListener?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                pipe?: <T extends NodeJS.WritableStream>(destination: T, options?: {
                    end?: boolean;
                }) => T;
                off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Writable;
                removeAllListeners?: (event?: string | symbol) => import("stream").Writable;
                setMaxListeners?: (n: number) => import("stream").Writable;
                getMaxListeners?: () => number;
                listeners?: (event: string | symbol) => Function[];
                rawListeners?: (event: string | symbol) => Function[];
                eventNames?: () => (string | symbol)[];
                listenerCount?: (type: string | symbol) => number;
            };
            stdout?: {
                readable?: boolean;
                readonly readableHighWaterMark?: number;
                readonly readableLength?: number;
                readonly readableObjectMode?: boolean;
                destroyed?: boolean;
                _read?: (size: number) => void;
                read?: (size?: number) => any;
                setEncoding?: (encoding: string) => import("stream").Readable;
                pause?: () => import("stream").Readable;
                resume?: () => import("stream").Readable;
                isPaused?: () => boolean;
                unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
                unshift?: (chunk: any, encoding?: BufferEncoding) => void;
                wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
                push?: (chunk: any, encoding?: string) => boolean;
                _destroy?: (error: Error, callback: (error?: Error) => void) => void;
                destroy?: (error?: Error) => void;
                addListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                emit?: {
                    (event: "close"): boolean;
                    (event: "data", chunk: any): boolean;
                    (event: "end"): boolean;
                    (event: "readable"): boolean;
                    (event: "error", err: Error): boolean;
                    (event: string | symbol, ...args: any[]): boolean;
                };
                on?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                once?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                prependListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                prependOnceListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                removeListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                    end?: boolean;
                }) => T_1;
                off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
                removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
                setMaxListeners?: (n: number) => import("stream").Readable;
                getMaxListeners?: () => number;
                listeners?: (event: string | symbol) => Function[];
                rawListeners?: (event: string | symbol) => Function[];
                eventNames?: () => (string | symbol)[];
                listenerCount?: (type: string | symbol) => number;
            };
            stderr?: {
                readable?: boolean;
                readonly readableHighWaterMark?: number;
                readonly readableLength?: number;
                readonly readableObjectMode?: boolean;
                destroyed?: boolean;
                _read?: (size: number) => void;
                read?: (size?: number) => any;
                setEncoding?: (encoding: string) => import("stream").Readable;
                pause?: () => import("stream").Readable;
                resume?: () => import("stream").Readable;
                isPaused?: () => boolean;
                unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
                unshift?: (chunk: any, encoding?: BufferEncoding) => void;
                wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
                push?: (chunk: any, encoding?: string) => boolean;
                _destroy?: (error: Error, callback: (error?: Error) => void) => void;
                destroy?: (error?: Error) => void;
                addListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                emit?: {
                    (event: "close"): boolean;
                    (event: "data", chunk: any): boolean;
                    (event: "end"): boolean;
                    (event: "readable"): boolean;
                    (event: "error", err: Error): boolean;
                    (event: string | symbol, ...args: any[]): boolean;
                };
                on?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                once?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                prependListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                prependOnceListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                removeListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                    end?: boolean;
                }) => T_1;
                off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
                removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
                setMaxListeners?: (n: number) => import("stream").Readable;
                getMaxListeners?: () => number;
                listeners?: (event: string | symbol) => Function[];
                rawListeners?: (event: string | symbol) => Function[];
                eventNames?: () => (string | symbol)[];
                listenerCount?: (type: string | symbol) => number;
            };
            readonly channel?: {
                close?: () => void;
                hasRef?: () => boolean;
                ref?: () => void;
                unref?: () => void;
            };
            readonly stdio?: [{
                readonly writable?: boolean;
                readonly writableEnded?: boolean;
                readonly writableFinished?: boolean;
                readonly writableHighWaterMark?: number;
                readonly writableLength?: number;
                readonly writableObjectMode?: boolean;
                destroyed?: boolean;
                _write?: (chunk: any, encoding: string, callback: (error?: Error) => void) => void;
                _writev?: (chunks: {
                    chunk: any;
                    encoding: string;
                }[], callback: (error?: Error) => void) => void;
                _destroy?: (error: Error, callback: (error?: Error) => void) => void;
                _final?: (callback: (error?: Error) => void) => void;
                write?: {
                    (chunk: any, cb?: (error: Error) => void): boolean;
                    (chunk: any, encoding: string, cb?: (error: Error) => void): boolean;
                };
                setDefaultEncoding?: (encoding: string) => import("stream").Writable;
                end?: {
                    (cb?: () => void): void;
                    (chunk: any, cb?: () => void): void;
                    (chunk: any, encoding: string, cb?: () => void): void;
                };
                cork?: () => void;
                uncork?: () => void;
                destroy?: (error?: Error) => void;
                addListener?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                emit?: {
                    (event: "close"): boolean;
                    (event: "drain"): boolean;
                    (event: "error", err: Error): boolean;
                    (event: "finish"): boolean;
                    (event: "pipe", src: import("stream").Readable): boolean;
                    (event: "unpipe", src: import("stream").Readable): boolean;
                    (event: string | symbol, ...args: any[]): boolean;
                };
                on?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                once?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                prependListener?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                prependOnceListener?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                removeListener?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                pipe?: <T extends NodeJS.WritableStream>(destination: T, options?: {
                    end?: boolean;
                }) => T;
                off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Writable;
                removeAllListeners?: (event?: string | symbol) => import("stream").Writable;
                setMaxListeners?: (n: number) => import("stream").Writable;
                getMaxListeners?: () => number;
                listeners?: (event: string | symbol) => Function[];
                rawListeners?: (event: string | symbol) => Function[];
                eventNames?: () => (string | symbol)[];
                listenerCount?: (type: string | symbol) => number;
            }?, {
                readable?: boolean;
                readonly readableHighWaterMark?: number;
                readonly readableLength?: number;
                readonly readableObjectMode?: boolean;
                destroyed?: boolean;
                _read?: (size: number) => void;
                read?: (size?: number) => any;
                setEncoding?: (encoding: string) => import("stream").Readable;
                pause?: () => import("stream").Readable;
                resume?: () => import("stream").Readable;
                isPaused?: () => boolean;
                unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
                unshift?: (chunk: any, encoding?: BufferEncoding) => void;
                wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
                push?: (chunk: any, encoding?: string) => boolean;
                _destroy?: (error: Error, callback: (error?: Error) => void) => void;
                destroy?: (error?: Error) => void;
                addListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                emit?: {
                    (event: "close"): boolean;
                    (event: "data", chunk: any): boolean;
                    (event: "end"): boolean;
                    (event: "readable"): boolean;
                    (event: "error", err: Error): boolean;
                    (event: string | symbol, ...args: any[]): boolean;
                };
                on?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                once?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                prependListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                prependOnceListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                removeListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                    end?: boolean;
                }) => T_1;
                off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
                removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
                setMaxListeners?: (n: number) => import("stream").Readable;
                getMaxListeners?: () => number;
                listeners?: (event: string | symbol) => Function[];
                rawListeners?: (event: string | symbol) => Function[];
                eventNames?: () => (string | symbol)[];
                listenerCount?: (type: string | symbol) => number;
            }?, {
                readable?: boolean;
                readonly readableHighWaterMark?: number;
                readonly readableLength?: number;
                readonly readableObjectMode?: boolean;
                destroyed?: boolean;
                _read?: (size: number) => void;
                read?: (size?: number) => any;
                setEncoding?: (encoding: string) => import("stream").Readable;
                pause?: () => import("stream").Readable;
                resume?: () => import("stream").Readable;
                isPaused?: () => boolean;
                unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
                unshift?: (chunk: any, encoding?: BufferEncoding) => void;
                wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
                push?: (chunk: any, encoding?: string) => boolean;
                _destroy?: (error: Error, callback: (error?: Error) => void) => void;
                destroy?: (error?: Error) => void;
                addListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                emit?: {
                    (event: "close"): boolean;
                    (event: "data", chunk: any): boolean;
                    (event: "end"): boolean;
                    (event: "readable"): boolean;
                    (event: "error", err: Error): boolean;
                    (event: string | symbol, ...args: any[]): boolean;
                };
                on?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                once?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                prependListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                prependOnceListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                removeListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                    end?: boolean;
                }) => T_1;
                off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
                removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
                setMaxListeners?: (n: number) => import("stream").Readable;
                getMaxListeners?: () => number;
                listeners?: (event: string | symbol) => Function[];
                rawListeners?: (event: string | symbol) => Function[];
                eventNames?: () => (string | symbol)[];
                listenerCount?: (type: string | symbol) => number;
            }?, ({
                readonly writable?: boolean;
                readonly writableEnded?: boolean;
                readonly writableFinished?: boolean;
                readonly writableHighWaterMark?: number;
                readonly writableLength?: number;
                readonly writableObjectMode?: boolean;
                destroyed?: boolean;
                _write?: (chunk: any, encoding: string, callback: (error?: Error) => void) => void;
                _writev?: (chunks: {
                    chunk: any;
                    encoding: string;
                }[], callback: (error?: Error) => void) => void;
                _destroy?: (error: Error, callback: (error?: Error) => void) => void;
                _final?: (callback: (error?: Error) => void) => void;
                write?: {
                    (chunk: any, cb?: (error: Error) => void): boolean;
                    (chunk: any, encoding: string, cb?: (error: Error) => void): boolean;
                };
                setDefaultEncoding?: (encoding: string) => import("stream").Writable;
                end?: {
                    (cb?: () => void): void;
                    (chunk: any, cb?: () => void): void;
                    (chunk: any, encoding: string, cb?: () => void): void;
                };
                cork?: () => void;
                uncork?: () => void;
                destroy?: (error?: Error) => void;
                addListener?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                emit?: {
                    (event: "close"): boolean;
                    (event: "drain"): boolean;
                    (event: "error", err: Error): boolean;
                    (event: "finish"): boolean;
                    (event: "pipe", src: import("stream").Readable): boolean;
                    (event: "unpipe", src: import("stream").Readable): boolean;
                    (event: string | symbol, ...args: any[]): boolean;
                };
                on?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                once?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                prependListener?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                prependOnceListener?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                removeListener?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                pipe?: <T extends NodeJS.WritableStream>(destination: T, options?: {
                    end?: boolean;
                }) => T;
                off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Writable;
                removeAllListeners?: (event?: string | symbol) => import("stream").Writable;
                setMaxListeners?: (n: number) => import("stream").Writable;
                getMaxListeners?: () => number;
                listeners?: (event: string | symbol) => Function[];
                rawListeners?: (event: string | symbol) => Function[];
                eventNames?: () => (string | symbol)[];
                listenerCount?: (type: string | symbol) => number;
            } | {
                readable?: boolean;
                readonly readableHighWaterMark?: number;
                readonly readableLength?: number;
                readonly readableObjectMode?: boolean;
                destroyed?: boolean;
                _read?: (size: number) => void;
                read?: (size?: number) => any;
                setEncoding?: (encoding: string) => import("stream").Readable;
                pause?: () => import("stream").Readable;
                resume?: () => import("stream").Readable;
                isPaused?: () => boolean;
                unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
                unshift?: (chunk: any, encoding?: BufferEncoding) => void;
                wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
                push?: (chunk: any, encoding?: string) => boolean;
                _destroy?: (error: Error, callback: (error?: Error) => void) => void;
                destroy?: (error?: Error) => void;
                addListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                emit?: {
                    (event: "close"): boolean;
                    (event: "data", chunk: any): boolean;
                    (event: "end"): boolean;
                    (event: "readable"): boolean;
                    (event: "error", err: Error): boolean;
                    (event: string | symbol, ...args: any[]): boolean;
                };
                on?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                once?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                prependListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                prependOnceListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                removeListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                    end?: boolean;
                }) => T_1;
                off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
                removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
                setMaxListeners?: (n: number) => import("stream").Readable;
                getMaxListeners?: () => number;
                listeners?: (event: string | symbol) => Function[];
                rawListeners?: (event: string | symbol) => Function[];
                eventNames?: () => (string | symbol)[];
                listenerCount?: (type: string | symbol) => number;
            })?, ({
                readonly writable?: boolean;
                readonly writableEnded?: boolean;
                readonly writableFinished?: boolean;
                readonly writableHighWaterMark?: number;
                readonly writableLength?: number;
                readonly writableObjectMode?: boolean;
                destroyed?: boolean;
                _write?: (chunk: any, encoding: string, callback: (error?: Error) => void) => void;
                _writev?: (chunks: {
                    chunk: any;
                    encoding: string;
                }[], callback: (error?: Error) => void) => void;
                _destroy?: (error: Error, callback: (error?: Error) => void) => void;
                _final?: (callback: (error?: Error) => void) => void;
                write?: {
                    (chunk: any, cb?: (error: Error) => void): boolean;
                    (chunk: any, encoding: string, cb?: (error: Error) => void): boolean;
                };
                setDefaultEncoding?: (encoding: string) => import("stream").Writable;
                end?: {
                    (cb?: () => void): void;
                    (chunk: any, cb?: () => void): void;
                    (chunk: any, encoding: string, cb?: () => void): void;
                };
                cork?: () => void;
                uncork?: () => void;
                destroy?: (error?: Error) => void;
                addListener?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                emit?: {
                    (event: "close"): boolean;
                    (event: "drain"): boolean;
                    (event: "error", err: Error): boolean;
                    (event: "finish"): boolean;
                    (event: "pipe", src: import("stream").Readable): boolean;
                    (event: "unpipe", src: import("stream").Readable): boolean;
                    (event: string | symbol, ...args: any[]): boolean;
                };
                on?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                once?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                prependListener?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                prependOnceListener?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                removeListener?: {
                    (event: "close", listener: () => void): import("stream").Writable;
                    (event: "drain", listener: () => void): import("stream").Writable;
                    (event: "error", listener: (err: Error) => void): import("stream").Writable;
                    (event: "finish", listener: () => void): import("stream").Writable;
                    (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
                };
                pipe?: <T extends NodeJS.WritableStream>(destination: T, options?: {
                    end?: boolean;
                }) => T;
                off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Writable;
                removeAllListeners?: (event?: string | symbol) => import("stream").Writable;
                setMaxListeners?: (n: number) => import("stream").Writable;
                getMaxListeners?: () => number;
                listeners?: (event: string | symbol) => Function[];
                rawListeners?: (event: string | symbol) => Function[];
                eventNames?: () => (string | symbol)[];
                listenerCount?: (type: string | symbol) => number;
            } | {
                readable?: boolean;
                readonly readableHighWaterMark?: number;
                readonly readableLength?: number;
                readonly readableObjectMode?: boolean;
                destroyed?: boolean;
                _read?: (size: number) => void;
                read?: (size?: number) => any;
                setEncoding?: (encoding: string) => import("stream").Readable;
                pause?: () => import("stream").Readable;
                resume?: () => import("stream").Readable;
                isPaused?: () => boolean;
                unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
                unshift?: (chunk: any, encoding?: BufferEncoding) => void;
                wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
                push?: (chunk: any, encoding?: string) => boolean;
                _destroy?: (error: Error, callback: (error?: Error) => void) => void;
                destroy?: (error?: Error) => void;
                addListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                emit?: {
                    (event: "close"): boolean;
                    (event: "data", chunk: any): boolean;
                    (event: "end"): boolean;
                    (event: "readable"): boolean;
                    (event: "error", err: Error): boolean;
                    (event: string | symbol, ...args: any[]): boolean;
                };
                on?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                once?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                prependListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                prependOnceListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                removeListener?: {
                    (event: "close", listener: () => void): import("stream").Readable;
                    (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                    (event: "end", listener: () => void): import("stream").Readable;
                    (event: "readable", listener: () => void): import("stream").Readable;
                    (event: "error", listener: (err: Error) => void): import("stream").Readable;
                    (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
                };
                pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                    end?: boolean;
                }) => T_1;
                off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
                removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
                setMaxListeners?: (n: number) => import("stream").Readable;
                getMaxListeners?: () => number;
                listeners?: (event: string | symbol) => Function[];
                rawListeners?: (event: string | symbol) => Function[];
                eventNames?: () => (string | symbol)[];
                listenerCount?: (type: string | symbol) => number;
            })?];
            readonly killed?: boolean;
            readonly pid?: number;
            readonly connected?: boolean;
            kill?: (signal?: number | "SIGABRT" | "SIGALRM" | "SIGBUS" | "SIGCHLD" | "SIGCONT" | "SIGFPE" | "SIGHUP" | "SIGILL" | "SIGINT" | "SIGIO" | "SIGIOT" | "SIGKILL" | "SIGPIPE" | "SIGPOLL" | "SIGPROF" | "SIGPWR" | "SIGQUIT" | "SIGSEGV" | "SIGSTKFLT" | "SIGSTOP" | "SIGSYS" | "SIGTERM" | "SIGTRAP" | "SIGTSTP" | "SIGTTIN" | "SIGTTOU" | "SIGUNUSED" | "SIGURG" | "SIGUSR1" | "SIGUSR2" | "SIGVTALRM" | "SIGWINCH" | "SIGXCPU" | "SIGXFSZ" | "SIGBREAK" | "SIGLOST" | "SIGINFO") => void;
            send?: {
                (message: any, callback?: (error: Error) => void): boolean;
                (message: any, sendHandle?: import("net").Socket | import("net").Server, callback?: (error: Error) => void): boolean;
                (message: any, sendHandle?: import("net").Socket | import("net").Server, options?: import("child_process").MessageOptions, callback?: (error: Error) => void): boolean;
            };
            disconnect?: () => void;
            unref?: () => void;
            ref?: () => void;
            addListener?: {
                (event: string, listener: (...args: any[]) => void): import("child_process").ChildProcess;
                (event: "close", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
                (event: "disconnect", listener: () => void): import("child_process").ChildProcess;
                (event: "error", listener: (err: Error) => void): import("child_process").ChildProcess;
                (event: "exit", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
                (event: "message", listener: (message: any, sendHandle: import("net").Socket | import("net").Server) => void): import("child_process").ChildProcess;
            };
            emit?: {
                (event: string | symbol, ...args: any[]): boolean;
                (event: "close", code: number, signal: NodeJS.Signals): boolean;
                (event: "disconnect"): boolean;
                (event: "error", err: Error): boolean;
                (event: "exit", code: number, signal: NodeJS.Signals): boolean;
                (event: "message", message: any, sendHandle: import("net").Socket | import("net").Server): boolean;
            };
            on?: {
                (event: string, listener: (...args: any[]) => void): import("child_process").ChildProcess;
                (event: "close", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
                (event: "disconnect", listener: () => void): import("child_process").ChildProcess;
                (event: "error", listener: (err: Error) => void): import("child_process").ChildProcess;
                (event: "exit", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
                (event: "message", listener: (message: any, sendHandle: import("net").Socket | import("net").Server) => void): import("child_process").ChildProcess;
            };
            once?: {
                (event: string, listener: (...args: any[]) => void): import("child_process").ChildProcess;
                (event: "close", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
                (event: "disconnect", listener: () => void): import("child_process").ChildProcess;
                (event: "error", listener: (err: Error) => void): import("child_process").ChildProcess;
                (event: "exit", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
                (event: "message", listener: (message: any, sendHandle: import("net").Socket | import("net").Server) => void): import("child_process").ChildProcess;
            };
            prependListener?: {
                (event: string, listener: (...args: any[]) => void): import("child_process").ChildProcess;
                (event: "close", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
                (event: "disconnect", listener: () => void): import("child_process").ChildProcess;
                (event: "error", listener: (err: Error) => void): import("child_process").ChildProcess;
                (event: "exit", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
                (event: "message", listener: (message: any, sendHandle: import("net").Socket | import("net").Server) => void): import("child_process").ChildProcess;
            };
            prependOnceListener?: {
                (event: string, listener: (...args: any[]) => void): import("child_process").ChildProcess;
                (event: "close", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
                (event: "disconnect", listener: () => void): import("child_process").ChildProcess;
                (event: "error", listener: (err: Error) => void): import("child_process").ChildProcess;
                (event: "exit", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
                (event: "message", listener: (message: any, sendHandle: import("net").Socket | import("net").Server) => void): import("child_process").ChildProcess;
            };
            removeListener?: (event: string | symbol, listener: (...args: any[]) => void) => import("child_process").ChildProcess;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("child_process").ChildProcess;
            removeAllListeners?: (event?: string | symbol) => import("child_process").ChildProcess;
            setMaxListeners?: (n: number) => import("child_process").ChildProcess;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        };
        status?: import("../../../../..").Agent.Status;
        currentMoveCommands?: string[];
        _currentMovePromise?: {
            then?: <TResult1 = void, TResult2 = never>(onfulfilled?: (value: void) => TResult1 | PromiseLike<TResult1>, onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>) => Promise<TResult1 | TResult2>;
            catch?: <TResult = never>(onrejected?: (reason: any) => TResult | PromiseLike<TResult>) => Promise<void | TResult>;
            finally?: (onfinally?: () => void) => Promise<void>;
        };
        _currentMoveResolve?: Function;
        _currentMoveReject?: Function;
        agentTimeStep?: number;
        _clearTimer?: Function;
        _install?: () => Promise<void>;
        _compile?: () => Promise<void>;
        _spawn?: () => Promise<import("child_process").ChildProcess>;
        _spawnProcess?: (command: string, args: string[]) => Promise<import("child_process").ChildProcess>;
        isTerminated?: () => boolean;
        _terminate?: () => Promise<void>;
        _disallowCommands?: () => void;
        _allowCommands?: () => void;
        isAllowedToSendCommands?: () => boolean;
        _setTimeout?: (fn: Function, delay: number, ...args: any[]) => void;
        _finishMove?: () => void;
        _setupMove?: () => void;
    }[];
    idToAgentsMap?: {
        clear?: () => void;
        delete?: (key: number) => boolean;
        forEach?: (callbackfn: (value: import("../../../../..").Agent, key: number, map: Map<number, import("../../../../..").Agent>) => void, thisArg?: any) => void;
        get?: (key: number) => import("../../../../..").Agent;
        has?: (key: number) => boolean;
        set?: (key: number, value: import("../../../../..").Agent) => Map<number, import("../../../../..").Agent>;
        readonly size?: number;
        entries?: () => IterableIterator<[number, import("../../../../..").Agent]>;
        keys?: () => IterableIterator<number>;
        values?: () => IterableIterator<import("../../../../..").Agent>;
    };
    timeStep?: number;
    matchEngine?: {
        setLogLevel?: (loggingLevel: import("../../../../..").Logger.LEVEL) => void;
        getEngineOptions?: () => import("../../../../..").MatchEngine.EngineOptions;
        setEngineOptions?: (newOptions?: {
            commandStreamType?: import("../../../../..").MatchEngine.COMMAND_STREAM_TYPE;
            commandDelimiter?: string;
            commandFinishSymbol?: string;
            commandFinishPolicy?: import("../../../../..").MatchEngine.COMMAND_FINISH_POLICIES;
            commandLines?: {
                max?: number;
                waitForNewline?: boolean;
            };
            noStdErr?: boolean;
            timeout?: {
                active?: boolean;
                max?: number;
                timeoutCallback?: (agent: import("../../../../..").Agent, match: Match, engineOptions: import("../../../../..").MatchEngine.EngineOptions) => void;
            };
            memory?: {
                active?: boolean;
                limit?: number;
                memoryCallback?: (agent: import("../../../../..").Agent, match: Match, engineOptions: import("../../../../..").MatchEngine.EngineOptions) => void;
                checkRate?: number;
                usePs?: boolean;
            };
        }) => void;
        initialize?: (agents: import("../../../../..").Agent[], match: Match) => Promise<void>;
        stop?: (match: Match) => Promise<void>;
        resume?: (match: Match) => Promise<void>;
        killAndClean?: (match: Match) => Promise<void>;
        kill?: (agent: import("../../../../..").Agent) => Promise<void>;
        getCommands?: (match: Match) => Promise<import("../../../../..").MatchEngine.Command[]>;
        send?: (match: Match, message: string, agentID: number) => Promise<boolean>;
        initializeCustom?: (match: Match) => Promise<boolean>;
        runCustom?: (match: Match) => Promise<string[]>;
        stopCustom?: (match: Match) => Promise<void>;
        resumeCustom?: (match: Match) => Promise<void>;
        killAndCleanCustom?: (match: Match) => Promise<void>;
    };
    log?: {
        identifier?: string;
        identifierColor?: import("colors").Color;
        level?: import("../../../../..").Logger.LEVEL;
        getIdentifier?: () => string;
        bar?: (type?: string) => string;
        importantBar?: () => void;
        important?: (...message: any[]) => void;
        systemIObar?: () => void;
        systemIO?: (...message: any[]) => void;
        systembar2?: () => void;
        system2?: (...message: any[]) => void;
        systembar?: () => void;
        system?: (...message: any[]) => void;
        detailbar?: () => void;
        detail?: (...message: any[]) => void;
        infobar?: () => void;
        info?: (...message: any[]) => void;
        warnbar?: () => void;
        warn?: (...message: any[]) => void;
        errorbar?: () => void;
        error?: (...message: any[]) => void;
    };
    results?: any;
    matchStatus?: Match.Status;
    mapAgentIDtoTournamentID?: {
        clear?: () => void;
        delete?: (key: number) => boolean;
        forEach?: (callbackfn: (value: import("../../../../..").Tournament.ID, key: number, map: Map<number, import("../../../../..").Tournament.ID>) => void, thisArg?: any) => void;
        get?: (key: number) => import("../../../../..").Tournament.ID;
        has?: (key: number) => boolean;
        set?: (key: number, value: import("../../../../..").Tournament.ID) => Map<number, import("../../../../..").Tournament.ID>;
        readonly size?: number;
        entries?: () => IterableIterator<[number, import("../../../../..").Tournament.ID]>;
        keys?: () => IterableIterator<number>;
        values?: () => IterableIterator<import("../../../../..").Tournament.ID>;
    };
    configs?: {
        [x: string]: any;
        name?: string;
        loggingLevel?: import("../../../../..").Logger.LEVEL;
        engineOptions?: {
            commandStreamType?: import("../../../../..").MatchEngine.COMMAND_STREAM_TYPE;
            commandDelimiter?: string;
            commandFinishSymbol?: string;
            commandFinishPolicy?: import("../../../../..").MatchEngine.COMMAND_FINISH_POLICIES;
            commandLines?: {
                max?: number;
                waitForNewline?: boolean;
            };
            noStdErr?: boolean;
            timeout?: {
                active?: boolean;
                max?: number;
                timeoutCallback?: (agent: import("../../../../..").Agent, match: Match, engineOptions: import("../../../../..").MatchEngine.EngineOptions) => void;
            };
            memory?: {
                active?: boolean;
                limit?: number;
                memoryCallback?: (agent: import("../../../../..").Agent, match: Match, engineOptions: import("../../../../..").MatchEngine.EngineOptions) => void;
                checkRate?: number;
                usePs?: boolean;
            };
        };
        secureMode?: boolean;
        agentOptions?: {
            name?: string;
            secureMode?: boolean;
            id?: number;
            tournamentID?: {
                readonly id?: string;
                name?: string;
                username?: string;
            };
            loggingLevel?: import("../../../../..").Logger.LEVEL;
            maxInstallTime?: number;
            maxCompileTime?: number;
            compileCommands?: {
                [x: string]: string[];
            };
            runCommands?: {
                [x: string]: string[];
            };
        };
        storeReplay?: boolean;
        storeReplayDirectory?: string;
    };
    matchProcess?: {
        stdin?: {
            readonly writable?: boolean;
            readonly writableEnded?: boolean;
            readonly writableFinished?: boolean;
            readonly writableHighWaterMark?: number;
            readonly writableLength?: number;
            readonly writableObjectMode?: boolean;
            destroyed?: boolean;
            _write?: (chunk: any, encoding: string, callback: (error?: Error) => void) => void;
            _writev?: (chunks: {
                chunk: any;
                encoding: string;
            }[], callback: (error?: Error) => void) => void;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            _final?: (callback: (error?: Error) => void) => void;
            write?: {
                (chunk: any, cb?: (error: Error) => void): boolean;
                (chunk: any, encoding: string, cb?: (error: Error) => void): boolean;
            };
            setDefaultEncoding?: (encoding: string) => import("stream").Writable;
            end?: {
                (cb?: () => void): void;
                (chunk: any, cb?: () => void): void;
                (chunk: any, encoding: string, cb?: () => void): void;
            };
            cork?: () => void;
            uncork?: () => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "drain"): boolean;
                (event: "error", err: Error): boolean;
                (event: "finish"): boolean;
                (event: "pipe", src: import("stream").Readable): boolean;
                (event: "unpipe", src: import("stream").Readable): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            pipe?: <T extends NodeJS.WritableStream>(destination: T, options?: {
                end?: boolean;
            }) => T;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Writable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Writable;
            setMaxListeners?: (n: number) => import("stream").Writable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        };
        stdout?: {
            readable?: boolean;
            readonly readableHighWaterMark?: number;
            readonly readableLength?: number;
            readonly readableObjectMode?: boolean;
            destroyed?: boolean;
            _read?: (size: number) => void;
            read?: (size?: number) => any;
            setEncoding?: (encoding: string) => import("stream").Readable;
            pause?: () => import("stream").Readable;
            resume?: () => import("stream").Readable;
            isPaused?: () => boolean;
            unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
            unshift?: (chunk: any, encoding?: BufferEncoding) => void;
            wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
            push?: (chunk: any, encoding?: string) => boolean;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "data", chunk: any): boolean;
                (event: "end"): boolean;
                (event: "readable"): boolean;
                (event: "error", err: Error): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                end?: boolean;
            }) => T_1;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
            setMaxListeners?: (n: number) => import("stream").Readable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        };
        stderr?: {
            readable?: boolean;
            readonly readableHighWaterMark?: number;
            readonly readableLength?: number;
            readonly readableObjectMode?: boolean;
            destroyed?: boolean;
            _read?: (size: number) => void;
            read?: (size?: number) => any;
            setEncoding?: (encoding: string) => import("stream").Readable;
            pause?: () => import("stream").Readable;
            resume?: () => import("stream").Readable;
            isPaused?: () => boolean;
            unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
            unshift?: (chunk: any, encoding?: BufferEncoding) => void;
            wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
            push?: (chunk: any, encoding?: string) => boolean;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "data", chunk: any): boolean;
                (event: "end"): boolean;
                (event: "readable"): boolean;
                (event: "error", err: Error): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                end?: boolean;
            }) => T_1;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
            setMaxListeners?: (n: number) => import("stream").Readable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        };
        readonly channel?: {
            close?: () => void;
            hasRef?: () => boolean;
            ref?: () => void;
            unref?: () => void;
        };
        readonly stdio?: [{
            readonly writable?: boolean;
            readonly writableEnded?: boolean;
            readonly writableFinished?: boolean;
            readonly writableHighWaterMark?: number;
            readonly writableLength?: number;
            readonly writableObjectMode?: boolean;
            destroyed?: boolean;
            _write?: (chunk: any, encoding: string, callback: (error?: Error) => void) => void;
            _writev?: (chunks: {
                chunk: any;
                encoding: string;
            }[], callback: (error?: Error) => void) => void;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            _final?: (callback: (error?: Error) => void) => void;
            write?: {
                (chunk: any, cb?: (error: Error) => void): boolean;
                (chunk: any, encoding: string, cb?: (error: Error) => void): boolean;
            };
            setDefaultEncoding?: (encoding: string) => import("stream").Writable;
            end?: {
                (cb?: () => void): void;
                (chunk: any, cb?: () => void): void;
                (chunk: any, encoding: string, cb?: () => void): void;
            };
            cork?: () => void;
            uncork?: () => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "drain"): boolean;
                (event: "error", err: Error): boolean;
                (event: "finish"): boolean;
                (event: "pipe", src: import("stream").Readable): boolean;
                (event: "unpipe", src: import("stream").Readable): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            pipe?: <T extends NodeJS.WritableStream>(destination: T, options?: {
                end?: boolean;
            }) => T;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Writable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Writable;
            setMaxListeners?: (n: number) => import("stream").Writable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        }?, {
            readable?: boolean;
            readonly readableHighWaterMark?: number;
            readonly readableLength?: number;
            readonly readableObjectMode?: boolean;
            destroyed?: boolean;
            _read?: (size: number) => void;
            read?: (size?: number) => any;
            setEncoding?: (encoding: string) => import("stream").Readable;
            pause?: () => import("stream").Readable;
            resume?: () => import("stream").Readable;
            isPaused?: () => boolean;
            unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
            unshift?: (chunk: any, encoding?: BufferEncoding) => void;
            wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
            push?: (chunk: any, encoding?: string) => boolean;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "data", chunk: any): boolean;
                (event: "end"): boolean;
                (event: "readable"): boolean;
                (event: "error", err: Error): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                end?: boolean;
            }) => T_1;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
            setMaxListeners?: (n: number) => import("stream").Readable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        }?, {
            readable?: boolean;
            readonly readableHighWaterMark?: number;
            readonly readableLength?: number;
            readonly readableObjectMode?: boolean;
            destroyed?: boolean;
            _read?: (size: number) => void;
            read?: (size?: number) => any;
            setEncoding?: (encoding: string) => import("stream").Readable;
            pause?: () => import("stream").Readable;
            resume?: () => import("stream").Readable;
            isPaused?: () => boolean;
            unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
            unshift?: (chunk: any, encoding?: BufferEncoding) => void;
            wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
            push?: (chunk: any, encoding?: string) => boolean;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "data", chunk: any): boolean;
                (event: "end"): boolean;
                (event: "readable"): boolean;
                (event: "error", err: Error): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                end?: boolean;
            }) => T_1;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
            setMaxListeners?: (n: number) => import("stream").Readable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        }?, ({
            readonly writable?: boolean;
            readonly writableEnded?: boolean;
            readonly writableFinished?: boolean;
            readonly writableHighWaterMark?: number;
            readonly writableLength?: number;
            readonly writableObjectMode?: boolean;
            destroyed?: boolean;
            _write?: (chunk: any, encoding: string, callback: (error?: Error) => void) => void;
            _writev?: (chunks: {
                chunk: any;
                encoding: string;
            }[], callback: (error?: Error) => void) => void;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            _final?: (callback: (error?: Error) => void) => void;
            write?: {
                (chunk: any, cb?: (error: Error) => void): boolean;
                (chunk: any, encoding: string, cb?: (error: Error) => void): boolean;
            };
            setDefaultEncoding?: (encoding: string) => import("stream").Writable;
            end?: {
                (cb?: () => void): void;
                (chunk: any, cb?: () => void): void;
                (chunk: any, encoding: string, cb?: () => void): void;
            };
            cork?: () => void;
            uncork?: () => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "drain"): boolean;
                (event: "error", err: Error): boolean;
                (event: "finish"): boolean;
                (event: "pipe", src: import("stream").Readable): boolean;
                (event: "unpipe", src: import("stream").Readable): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            pipe?: <T extends NodeJS.WritableStream>(destination: T, options?: {
                end?: boolean;
            }) => T;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Writable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Writable;
            setMaxListeners?: (n: number) => import("stream").Writable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        } | {
            readable?: boolean;
            readonly readableHighWaterMark?: number;
            readonly readableLength?: number;
            readonly readableObjectMode?: boolean;
            destroyed?: boolean;
            _read?: (size: number) => void;
            read?: (size?: number) => any;
            setEncoding?: (encoding: string) => import("stream").Readable;
            pause?: () => import("stream").Readable;
            resume?: () => import("stream").Readable;
            isPaused?: () => boolean;
            unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
            unshift?: (chunk: any, encoding?: BufferEncoding) => void;
            wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
            push?: (chunk: any, encoding?: string) => boolean;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "data", chunk: any): boolean;
                (event: "end"): boolean;
                (event: "readable"): boolean;
                (event: "error", err: Error): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                end?: boolean;
            }) => T_1;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
            setMaxListeners?: (n: number) => import("stream").Readable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        })?, ({
            readonly writable?: boolean;
            readonly writableEnded?: boolean;
            readonly writableFinished?: boolean;
            readonly writableHighWaterMark?: number;
            readonly writableLength?: number;
            readonly writableObjectMode?: boolean;
            destroyed?: boolean;
            _write?: (chunk: any, encoding: string, callback: (error?: Error) => void) => void;
            _writev?: (chunks: {
                chunk: any;
                encoding: string;
            }[], callback: (error?: Error) => void) => void;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            _final?: (callback: (error?: Error) => void) => void;
            write?: {
                (chunk: any, cb?: (error: Error) => void): boolean;
                (chunk: any, encoding: string, cb?: (error: Error) => void): boolean;
            };
            setDefaultEncoding?: (encoding: string) => import("stream").Writable;
            end?: {
                (cb?: () => void): void;
                (chunk: any, cb?: () => void): void;
                (chunk: any, encoding: string, cb?: () => void): void;
            };
            cork?: () => void;
            uncork?: () => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "drain"): boolean;
                (event: "error", err: Error): boolean;
                (event: "finish"): boolean;
                (event: "pipe", src: import("stream").Readable): boolean;
                (event: "unpipe", src: import("stream").Readable): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            pipe?: <T extends NodeJS.WritableStream>(destination: T, options?: {
                end?: boolean;
            }) => T;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Writable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Writable;
            setMaxListeners?: (n: number) => import("stream").Writable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        } | {
            readable?: boolean;
            readonly readableHighWaterMark?: number;
            readonly readableLength?: number;
            readonly readableObjectMode?: boolean;
            destroyed?: boolean;
            _read?: (size: number) => void;
            read?: (size?: number) => any;
            setEncoding?: (encoding: string) => import("stream").Readable;
            pause?: () => import("stream").Readable;
            resume?: () => import("stream").Readable;
            isPaused?: () => boolean;
            unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
            unshift?: (chunk: any, encoding?: BufferEncoding) => void;
            wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
            push?: (chunk: any, encoding?: string) => boolean;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "data", chunk: any): boolean;
                (event: "end"): boolean;
                (event: "readable"): boolean;
                (event: "error", err: Error): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                end?: boolean;
            }) => T_1;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
            setMaxListeners?: (n: number) => import("stream").Readable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        })?];
        readonly killed?: boolean;
        readonly pid?: number;
        readonly connected?: boolean;
        kill?: (signal?: number | "SIGABRT" | "SIGALRM" | "SIGBUS" | "SIGCHLD" | "SIGCONT" | "SIGFPE" | "SIGHUP" | "SIGILL" | "SIGINT" | "SIGIO" | "SIGIOT" | "SIGKILL" | "SIGPIPE" | "SIGPOLL" | "SIGPROF" | "SIGPWR" | "SIGQUIT" | "SIGSEGV" | "SIGSTKFLT" | "SIGSTOP" | "SIGSYS" | "SIGTERM" | "SIGTRAP" | "SIGTSTP" | "SIGTTIN" | "SIGTTOU" | "SIGUNUSED" | "SIGURG" | "SIGUSR1" | "SIGUSR2" | "SIGVTALRM" | "SIGWINCH" | "SIGXCPU" | "SIGXFSZ" | "SIGBREAK" | "SIGLOST" | "SIGINFO") => void;
        send?: {
            (message: any, callback?: (error: Error) => void): boolean;
            (message: any, sendHandle?: import("net").Socket | import("net").Server, callback?: (error: Error) => void): boolean;
            (message: any, sendHandle?: import("net").Socket | import("net").Server, options?: import("child_process").MessageOptions, callback?: (error: Error) => void): boolean;
        };
        disconnect?: () => void;
        unref?: () => void;
        ref?: () => void;
        addListener?: {
            (event: string, listener: (...args: any[]) => void): import("child_process").ChildProcess;
            (event: "close", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "disconnect", listener: () => void): import("child_process").ChildProcess;
            (event: "error", listener: (err: Error) => void): import("child_process").ChildProcess;
            (event: "exit", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "message", listener: (message: any, sendHandle: import("net").Socket | import("net").Server) => void): import("child_process").ChildProcess;
        };
        emit?: {
            (event: string | symbol, ...args: any[]): boolean;
            (event: "close", code: number, signal: NodeJS.Signals): boolean;
            (event: "disconnect"): boolean;
            (event: "error", err: Error): boolean;
            (event: "exit", code: number, signal: NodeJS.Signals): boolean;
            (event: "message", message: any, sendHandle: import("net").Socket | import("net").Server): boolean;
        };
        on?: {
            (event: string, listener: (...args: any[]) => void): import("child_process").ChildProcess;
            (event: "close", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "disconnect", listener: () => void): import("child_process").ChildProcess;
            (event: "error", listener: (err: Error) => void): import("child_process").ChildProcess;
            (event: "exit", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "message", listener: (message: any, sendHandle: import("net").Socket | import("net").Server) => void): import("child_process").ChildProcess;
        };
        once?: {
            (event: string, listener: (...args: any[]) => void): import("child_process").ChildProcess;
            (event: "close", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "disconnect", listener: () => void): import("child_process").ChildProcess;
            (event: "error", listener: (err: Error) => void): import("child_process").ChildProcess;
            (event: "exit", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "message", listener: (message: any, sendHandle: import("net").Socket | import("net").Server) => void): import("child_process").ChildProcess;
        };
        prependListener?: {
            (event: string, listener: (...args: any[]) => void): import("child_process").ChildProcess;
            (event: "close", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "disconnect", listener: () => void): import("child_process").ChildProcess;
            (event: "error", listener: (err: Error) => void): import("child_process").ChildProcess;
            (event: "exit", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "message", listener: (message: any, sendHandle: import("net").Socket | import("net").Server) => void): import("child_process").ChildProcess;
        };
        prependOnceListener?: {
            (event: string, listener: (...args: any[]) => void): import("child_process").ChildProcess;
            (event: "close", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "disconnect", listener: () => void): import("child_process").ChildProcess;
            (event: "error", listener: (err: Error) => void): import("child_process").ChildProcess;
            (event: "exit", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "message", listener: (message: any, sendHandle: import("net").Socket | import("net").Server) => void): import("child_process").ChildProcess;
        };
        removeListener?: (event: string | symbol, listener: (...args: any[]) => void) => import("child_process").ChildProcess;
        off?: (event: string | symbol, listener: (...args: any[]) => void) => import("child_process").ChildProcess;
        removeAllListeners?: (event?: string | symbol) => import("child_process").ChildProcess;
        setMaxListeners?: (n: number) => import("child_process").ChildProcess;
        getMaxListeners?: () => number;
        listeners?: (event: string | symbol) => Function[];
        rawListeners?: (event: string | symbol) => Function[];
        eventNames?: () => (string | symbol)[];
        listenerCount?: (type: string | symbol) => number;
    };
    matchProcessTimer?: any;
    replayFile?: string;
    replayFileKey?: string;
    design?: {
        log?: {
            identifier?: string;
            identifierColor?: import("colors").Color;
            level?: import("../../../../..").Logger.LEVEL;
            getIdentifier?: () => string;
            bar?: (type?: string) => string;
            importantBar?: () => void;
            important?: (...message: any[]) => void;
            systemIObar?: () => void;
            systemIO?: (...message: any[]) => void;
            systembar2?: () => void;
            system2?: (...message: any[]) => void;
            systembar?: () => void;
            system?: (...message: any[]) => void;
            detailbar?: () => void;
            detail?: (...message: any[]) => void;
            infobar?: () => void;
            info?: (...message: any[]) => void;
            warnbar?: () => void;
            warn?: (...message: any[]) => void;
            errorbar?: () => void;
            error?: (...message: any[]) => void;
        };
        name?: {
            [x: number]: string;
            toString?: () => string;
            charAt?: (pos: number) => string;
            charCodeAt?: (index: number) => number;
            concat?: (...strings: string[]) => string;
            indexOf?: (searchString: string, position?: number) => number;
            lastIndexOf?: (searchString: string, position?: number) => number;
            localeCompare?: {
                (that: string): number;
                (that: string, locales?: string | string[], options?: Intl.CollatorOptions): number;
            };
            match?: {
                (regexp: string | RegExp): RegExpMatchArray;
                (matcher: {
                    [Symbol.match](string: string): RegExpMatchArray;
                }): RegExpMatchArray;
            };
            replace?: {
                (searchValue: string | RegExp, replaceValue: string): string;
                (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
                (searchValue: {
                    [Symbol.replace](string: string, replaceValue: string): string;
                }, replaceValue: string): string;
                (searchValue: {
                    [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
                }, replacer: (substring: string, ...args: any[]) => string): string;
            };
            search?: {
                (regexp: string | RegExp): number;
                (searcher: {
                    [Symbol.search](string: string): number;
                }): number;
            };
            slice?: (start?: number, end?: number) => string;
            split?: {
                (separator: string | RegExp, limit?: number): string[];
                (splitter: {
                    [Symbol.split](string: string, limit?: number): string[];
                }, limit?: number): string[];
            };
            substring?: (start: number, end?: number) => string;
            toLowerCase?: () => string;
            toLocaleLowerCase?: (locales?: string | string[]) => string;
            toUpperCase?: () => string;
            toLocaleUpperCase?: (locales?: string | string[]) => string;
            trim?: () => string;
            readonly length?: number;
            substr?: (from: number, length?: number) => string;
            valueOf?: () => string;
            codePointAt?: (pos: number) => number;
            includes?: (searchString: string, position?: number) => boolean;
            endsWith?: (searchString: string, endPosition?: number) => boolean;
            normalize?: {
                (form: "NFC" | "NFD" | "NFKC" | "NFKD"): string;
                (form?: string): string;
            };
            repeat?: (count: number) => string;
            startsWith?: (searchString: string, position?: number) => boolean;
            anchor?: (name: string) => string;
            big?: () => string;
            blink?: () => string;
            bold?: () => string;
            fixed?: () => string;
            fontcolor?: (color: string) => string;
            fontsize?: {
                (size: number): string;
                (size: string): string;
            };
            italics?: () => string;
            link?: (url: string) => string;
            small?: () => string;
            strike?: () => string;
            sub?: () => string;
            sup?: () => string;
            padStart?: (maxLength: number, fillString?: string) => string;
            padEnd?: (maxLength: number, fillString?: string) => string;
            trimLeft?: () => string;
            trimRight?: () => string;
            strip?: string;
            stripColors?: string;
            black?: string;
            red?: string;
            green?: string;
            yellow?: string;
            blue?: string;
            magenta?: string;
            cyan?: string;
            white?: string;
            gray?: string;
            grey?: string;
            bgBlack?: string;
            bgRed?: string;
            bgGreen?: string;
            bgYellow?: string;
            bgBlue?: string;
            bgMagenta?: string;
            bgCyan?: string;
            bgWhite?: string;
            reset?: string;
            dim?: string;
            italic?: string;
            underline?: string;
            inverse?: string;
            hidden?: string;
            strikethrough?: string;
            rainbow?: string;
            zebra?: string;
            america?: string;
            trap?: string;
            random?: string;
            zalgo?: string;
        };
        setLogLevel?: (level: import("../../../../..").Logger.LEVEL) => void;
        getDesignOptions?: () => import("../../../../..").DesignOptions;
        initialize?: (match: Match) => Promise<void>;
        update?: (match: Match, commands: import("../../../../..").MatchEngine.Command[]) => Promise<Match.Status>;
        getResults?: (match: Match) => Promise<any>;
    };
    agentFiles?: {
        [x: number]: string;
        toString?: () => string;
        charAt?: (pos: number) => string;
        charCodeAt?: (index: number) => number;
        concat?: (...strings: string[]) => string;
        indexOf?: (searchString: string, position?: number) => number;
        lastIndexOf?: (searchString: string, position?: number) => number;
        localeCompare?: {
            (that: string): number;
            (that: string, locales?: string | string[], options?: Intl.CollatorOptions): number;
        };
        match?: {
            (regexp: string | RegExp): RegExpMatchArray;
            (matcher: {
                [Symbol.match](string: string): RegExpMatchArray;
            }): RegExpMatchArray;
        };
        replace?: {
            (searchValue: string | RegExp, replaceValue: string): string;
            (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
            (searchValue: {
                [Symbol.replace](string: string, replaceValue: string): string;
            }, replaceValue: string): string;
            (searchValue: {
                [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
            }, replacer: (substring: string, ...args: any[]) => string): string;
        };
        search?: {
            (regexp: string | RegExp): number;
            (searcher: {
                [Symbol.search](string: string): number;
            }): number;
        };
        slice?: (start?: number, end?: number) => string;
        split?: {
            (separator: string | RegExp, limit?: number): string[];
            (splitter: {
                [Symbol.split](string: string, limit?: number): string[];
            }, limit?: number): string[];
        };
        substring?: (start: number, end?: number) => string;
        toLowerCase?: () => string;
        toLocaleLowerCase?: (locales?: string | string[]) => string;
        toUpperCase?: () => string;
        toLocaleUpperCase?: (locales?: string | string[]) => string;
        trim?: () => string;
        readonly length?: number;
        substr?: (from: number, length?: number) => string;
        valueOf?: () => string;
        codePointAt?: (pos: number) => number;
        includes?: (searchString: string, position?: number) => boolean;
        endsWith?: (searchString: string, endPosition?: number) => boolean;
        normalize?: {
            (form: "NFC" | "NFD" | "NFKC" | "NFKD"): string;
            (form?: string): string;
        };
        repeat?: (count: number) => string;
        startsWith?: (searchString: string, position?: number) => boolean;
        anchor?: (name: string) => string;
        big?: () => string;
        blink?: () => string;
        bold?: () => string;
        fixed?: () => string;
        fontcolor?: (color: string) => string;
        fontsize?: {
            (size: number): string;
            (size: string): string;
        };
        italics?: () => string;
        link?: (url: string) => string;
        small?: () => string;
        strike?: () => string;
        sub?: () => string;
        sup?: () => string;
        padStart?: (maxLength: number, fillString?: string) => string;
        padEnd?: (maxLength: number, fillString?: string) => string;
        trimLeft?: () => string;
        trimRight?: () => string;
        strip?: string;
        stripColors?: string;
        black?: string;
        red?: string;
        green?: string;
        yellow?: string;
        blue?: string;
        magenta?: string;
        cyan?: string;
        white?: string;
        gray?: string;
        grey?: string;
        bgBlack?: string;
        bgRed?: string;
        bgGreen?: string;
        bgYellow?: string;
        bgBlue?: string;
        bgMagenta?: string;
        bgCyan?: string;
        bgWhite?: string;
        reset?: string;
        dim?: string;
        italic?: string;
        underline?: string;
        inverse?: string;
        hidden?: string;
        strikethrough?: string;
        rainbow?: string;
        zebra?: string;
        america?: string;
        trap?: string;
        random?: string;
        zalgo?: string;
    }[] | {
        file?: string;
        name?: string;
        botkey?: string;
    }[] | {
        file?: string;
        tournamentID?: {
            readonly id?: string;
            name?: string;
            username?: string;
        };
        botkey?: string;
    }[];
    initialize?: () => Promise<boolean>;
    run?: () => Promise<any>;
    next?: () => Promise<Match.Status>;
    stop?: () => Promise<unknown>;
    resume?: () => Promise<unknown>;
    kill?: (agent: number | import("../../../../..").Agent) => Promise<void>;
    getResults?: () => Promise<any>;
    sendAll?: (message: string) => Promise<boolean>;
    send?: (message: string, receiver: number | import("../../../../..").Agent) => Promise<void>;
    throw?: (agentID: number, error: Error) => Promise<void>;
    destroy?: () => Promise<void>;
};
export default router;
