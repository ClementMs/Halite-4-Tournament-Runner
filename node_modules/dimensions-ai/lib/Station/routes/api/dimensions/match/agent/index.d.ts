/// <reference types="node" />
/**
 * API for dimension's agents
 */
import express from 'express';
import { Agent } from '../../../../../../Agent';
declare const router: import("express-serve-static-core").Router;
/**
 * Gets agent by agentID in request. Requires a match to be stored
 */
export declare const getAgent: (req: express.Request<import("express-serve-static-core").ParamsDictionary>, res: express.Response<any>, next: express.NextFunction) => void;
/**
 * Picks out relevant fields of the agent
 */
export declare const pickAgent: (agent: Agent) => {
    id?: number;
    tournamentID?: {
        readonly id?: string;
        name?: string;
        username?: string;
    };
    name?: string;
    src?: string;
    ext?: string;
    srcNoExt?: string;
    cwd?: string;
    cmd?: string;
    file?: string;
    options?: {
        name?: string;
        secureMode?: boolean;
        id?: number;
        tournamentID?: {
            readonly id?: string;
            name?: string;
            username?: string;
        };
        loggingLevel?: import("../../../../../..").Logger.LEVEL;
        maxInstallTime?: number;
        maxCompileTime?: number;
        compileCommands?: {
            [x: string]: string[];
        };
        runCommands?: {
            [x: string]: string[];
        };
    };
    creationDate?: {
        toString?: () => string;
        toDateString?: () => string;
        toTimeString?: () => string;
        toLocaleString?: {
            (): string;
            (locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;
        };
        toLocaleDateString?: {
            (): string;
            (locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;
        };
        toLocaleTimeString?: {
            (): string;
            (locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;
        };
        valueOf?: () => number;
        getTime?: () => number;
        getFullYear?: () => number;
        getUTCFullYear?: () => number;
        getMonth?: () => number;
        getUTCMonth?: () => number;
        getDate?: () => number;
        getUTCDate?: () => number;
        getDay?: () => number;
        getUTCDay?: () => number;
        getHours?: () => number;
        getUTCHours?: () => number;
        getMinutes?: () => number;
        getUTCMinutes?: () => number;
        getSeconds?: () => number;
        getUTCSeconds?: () => number;
        getMilliseconds?: () => number;
        getUTCMilliseconds?: () => number;
        getTimezoneOffset?: () => number;
        setTime?: (time: number) => number;
        setMilliseconds?: (ms: number) => number;
        setUTCMilliseconds?: (ms: number) => number;
        setSeconds?: (sec: number, ms?: number) => number;
        setUTCSeconds?: (sec: number, ms?: number) => number;
        setMinutes?: (min: number, sec?: number, ms?: number) => number;
        setUTCMinutes?: (min: number, sec?: number, ms?: number) => number;
        setHours?: (hours: number, min?: number, sec?: number, ms?: number) => number;
        setUTCHours?: (hours: number, min?: number, sec?: number, ms?: number) => number;
        setDate?: (date: number) => number;
        setUTCDate?: (date: number) => number;
        setMonth?: (month: number, date?: number) => number;
        setUTCMonth?: (month: number, date?: number) => number;
        setFullYear?: (year: number, month?: number, date?: number) => number;
        setUTCFullYear?: (year: number, month?: number, date?: number) => number;
        toUTCString?: () => string;
        toISOString?: () => string;
        toJSON?: (key?: any) => string;
        getVarDate?: () => VarDate;
    };
    _buffer?: string[];
    memoryWatchInterval?: any;
    process?: {
        stdin?: {
            readonly writable?: boolean;
            readonly writableEnded?: boolean;
            readonly writableFinished?: boolean;
            readonly writableHighWaterMark?: number;
            readonly writableLength?: number;
            readonly writableObjectMode?: boolean;
            destroyed?: boolean;
            _write?: (chunk: any, encoding: string, callback: (error?: Error) => void) => void;
            _writev?: (chunks: {
                chunk: any;
                encoding: string;
            }[], callback: (error?: Error) => void) => void;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            _final?: (callback: (error?: Error) => void) => void;
            write?: {
                (chunk: any, cb?: (error: Error) => void): boolean;
                (chunk: any, encoding: string, cb?: (error: Error) => void): boolean;
            };
            setDefaultEncoding?: (encoding: string) => import("stream").Writable;
            end?: {
                (cb?: () => void): void;
                (chunk: any, cb?: () => void): void;
                (chunk: any, encoding: string, cb?: () => void): void;
            };
            cork?: () => void;
            uncork?: () => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "drain"): boolean;
                (event: "error", err: Error): boolean;
                (event: "finish"): boolean;
                (event: "pipe", src: import("stream").Readable): boolean;
                (event: "unpipe", src: import("stream").Readable): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            pipe?: <T extends NodeJS.WritableStream>(destination: T, options?: {
                end?: boolean;
            }) => T;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Writable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Writable;
            setMaxListeners?: (n: number) => import("stream").Writable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        };
        stdout?: {
            readable?: boolean;
            readonly readableHighWaterMark?: number;
            readonly readableLength?: number;
            readonly readableObjectMode?: boolean;
            destroyed?: boolean;
            _read?: (size: number) => void;
            read?: (size?: number) => any;
            setEncoding?: (encoding: string) => import("stream").Readable;
            pause?: () => import("stream").Readable;
            resume?: () => import("stream").Readable;
            isPaused?: () => boolean;
            unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
            unshift?: (chunk: any, encoding?: BufferEncoding) => void;
            wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
            push?: (chunk: any, encoding?: string) => boolean;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "data", chunk: any): boolean;
                (event: "end"): boolean;
                (event: "readable"): boolean;
                (event: "error", err: Error): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                end?: boolean;
            }) => T_1;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
            setMaxListeners?: (n: number) => import("stream").Readable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        };
        stderr?: {
            readable?: boolean;
            readonly readableHighWaterMark?: number;
            readonly readableLength?: number;
            readonly readableObjectMode?: boolean;
            destroyed?: boolean;
            _read?: (size: number) => void;
            read?: (size?: number) => any;
            setEncoding?: (encoding: string) => import("stream").Readable;
            pause?: () => import("stream").Readable;
            resume?: () => import("stream").Readable;
            isPaused?: () => boolean;
            unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
            unshift?: (chunk: any, encoding?: BufferEncoding) => void;
            wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
            push?: (chunk: any, encoding?: string) => boolean;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "data", chunk: any): boolean;
                (event: "end"): boolean;
                (event: "readable"): boolean;
                (event: "error", err: Error): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                end?: boolean;
            }) => T_1;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
            setMaxListeners?: (n: number) => import("stream").Readable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        };
        readonly channel?: {
            close?: () => void;
            hasRef?: () => boolean;
            ref?: () => void;
            unref?: () => void;
        };
        readonly stdio?: [{
            readonly writable?: boolean;
            readonly writableEnded?: boolean;
            readonly writableFinished?: boolean;
            readonly writableHighWaterMark?: number;
            readonly writableLength?: number;
            readonly writableObjectMode?: boolean;
            destroyed?: boolean;
            _write?: (chunk: any, encoding: string, callback: (error?: Error) => void) => void;
            _writev?: (chunks: {
                chunk: any;
                encoding: string;
            }[], callback: (error?: Error) => void) => void;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            _final?: (callback: (error?: Error) => void) => void;
            write?: {
                (chunk: any, cb?: (error: Error) => void): boolean;
                (chunk: any, encoding: string, cb?: (error: Error) => void): boolean;
            };
            setDefaultEncoding?: (encoding: string) => import("stream").Writable;
            end?: {
                (cb?: () => void): void;
                (chunk: any, cb?: () => void): void;
                (chunk: any, encoding: string, cb?: () => void): void;
            };
            cork?: () => void;
            uncork?: () => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "drain"): boolean;
                (event: "error", err: Error): boolean;
                (event: "finish"): boolean;
                (event: "pipe", src: import("stream").Readable): boolean;
                (event: "unpipe", src: import("stream").Readable): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            pipe?: <T extends NodeJS.WritableStream>(destination: T, options?: {
                end?: boolean;
            }) => T;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Writable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Writable;
            setMaxListeners?: (n: number) => import("stream").Writable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        }?, {
            readable?: boolean;
            readonly readableHighWaterMark?: number;
            readonly readableLength?: number;
            readonly readableObjectMode?: boolean;
            destroyed?: boolean;
            _read?: (size: number) => void;
            read?: (size?: number) => any;
            setEncoding?: (encoding: string) => import("stream").Readable;
            pause?: () => import("stream").Readable;
            resume?: () => import("stream").Readable;
            isPaused?: () => boolean;
            unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
            unshift?: (chunk: any, encoding?: BufferEncoding) => void;
            wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
            push?: (chunk: any, encoding?: string) => boolean;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "data", chunk: any): boolean;
                (event: "end"): boolean;
                (event: "readable"): boolean;
                (event: "error", err: Error): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                end?: boolean;
            }) => T_1;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
            setMaxListeners?: (n: number) => import("stream").Readable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        }?, {
            readable?: boolean;
            readonly readableHighWaterMark?: number;
            readonly readableLength?: number;
            readonly readableObjectMode?: boolean;
            destroyed?: boolean;
            _read?: (size: number) => void;
            read?: (size?: number) => any;
            setEncoding?: (encoding: string) => import("stream").Readable;
            pause?: () => import("stream").Readable;
            resume?: () => import("stream").Readable;
            isPaused?: () => boolean;
            unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
            unshift?: (chunk: any, encoding?: BufferEncoding) => void;
            wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
            push?: (chunk: any, encoding?: string) => boolean;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "data", chunk: any): boolean;
                (event: "end"): boolean;
                (event: "readable"): boolean;
                (event: "error", err: Error): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                end?: boolean;
            }) => T_1;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
            setMaxListeners?: (n: number) => import("stream").Readable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        }?, ({
            readonly writable?: boolean;
            readonly writableEnded?: boolean;
            readonly writableFinished?: boolean;
            readonly writableHighWaterMark?: number;
            readonly writableLength?: number;
            readonly writableObjectMode?: boolean;
            destroyed?: boolean;
            _write?: (chunk: any, encoding: string, callback: (error?: Error) => void) => void;
            _writev?: (chunks: {
                chunk: any;
                encoding: string;
            }[], callback: (error?: Error) => void) => void;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            _final?: (callback: (error?: Error) => void) => void;
            write?: {
                (chunk: any, cb?: (error: Error) => void): boolean;
                (chunk: any, encoding: string, cb?: (error: Error) => void): boolean;
            };
            setDefaultEncoding?: (encoding: string) => import("stream").Writable;
            end?: {
                (cb?: () => void): void;
                (chunk: any, cb?: () => void): void;
                (chunk: any, encoding: string, cb?: () => void): void;
            };
            cork?: () => void;
            uncork?: () => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "drain"): boolean;
                (event: "error", err: Error): boolean;
                (event: "finish"): boolean;
                (event: "pipe", src: import("stream").Readable): boolean;
                (event: "unpipe", src: import("stream").Readable): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            pipe?: <T extends NodeJS.WritableStream>(destination: T, options?: {
                end?: boolean;
            }) => T;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Writable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Writable;
            setMaxListeners?: (n: number) => import("stream").Writable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        } | {
            readable?: boolean;
            readonly readableHighWaterMark?: number;
            readonly readableLength?: number;
            readonly readableObjectMode?: boolean;
            destroyed?: boolean;
            _read?: (size: number) => void;
            read?: (size?: number) => any;
            setEncoding?: (encoding: string) => import("stream").Readable;
            pause?: () => import("stream").Readable;
            resume?: () => import("stream").Readable;
            isPaused?: () => boolean;
            unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
            unshift?: (chunk: any, encoding?: BufferEncoding) => void;
            wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
            push?: (chunk: any, encoding?: string) => boolean;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "data", chunk: any): boolean;
                (event: "end"): boolean;
                (event: "readable"): boolean;
                (event: "error", err: Error): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                end?: boolean;
            }) => T_1;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
            setMaxListeners?: (n: number) => import("stream").Readable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        })?, ({
            readonly writable?: boolean;
            readonly writableEnded?: boolean;
            readonly writableFinished?: boolean;
            readonly writableHighWaterMark?: number;
            readonly writableLength?: number;
            readonly writableObjectMode?: boolean;
            destroyed?: boolean;
            _write?: (chunk: any, encoding: string, callback: (error?: Error) => void) => void;
            _writev?: (chunks: {
                chunk: any;
                encoding: string;
            }[], callback: (error?: Error) => void) => void;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            _final?: (callback: (error?: Error) => void) => void;
            write?: {
                (chunk: any, cb?: (error: Error) => void): boolean;
                (chunk: any, encoding: string, cb?: (error: Error) => void): boolean;
            };
            setDefaultEncoding?: (encoding: string) => import("stream").Writable;
            end?: {
                (cb?: () => void): void;
                (chunk: any, cb?: () => void): void;
                (chunk: any, encoding: string, cb?: () => void): void;
            };
            cork?: () => void;
            uncork?: () => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "drain"): boolean;
                (event: "error", err: Error): boolean;
                (event: "finish"): boolean;
                (event: "pipe", src: import("stream").Readable): boolean;
                (event: "unpipe", src: import("stream").Readable): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Writable;
                (event: "drain", listener: () => void): import("stream").Writable;
                (event: "error", listener: (err: Error) => void): import("stream").Writable;
                (event: "finish", listener: () => void): import("stream").Writable;
                (event: "pipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: "unpipe", listener: (src: import("stream").Readable) => void): import("stream").Writable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Writable;
            };
            pipe?: <T extends NodeJS.WritableStream>(destination: T, options?: {
                end?: boolean;
            }) => T;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Writable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Writable;
            setMaxListeners?: (n: number) => import("stream").Writable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        } | {
            readable?: boolean;
            readonly readableHighWaterMark?: number;
            readonly readableLength?: number;
            readonly readableObjectMode?: boolean;
            destroyed?: boolean;
            _read?: (size: number) => void;
            read?: (size?: number) => any;
            setEncoding?: (encoding: string) => import("stream").Readable;
            pause?: () => import("stream").Readable;
            resume?: () => import("stream").Readable;
            isPaused?: () => boolean;
            unpipe?: (destination?: NodeJS.WritableStream) => import("stream").Readable;
            unshift?: (chunk: any, encoding?: BufferEncoding) => void;
            wrap?: (oldStream: NodeJS.ReadableStream) => import("stream").Readable;
            push?: (chunk: any, encoding?: string) => boolean;
            _destroy?: (error: Error, callback: (error?: Error) => void) => void;
            destroy?: (error?: Error) => void;
            addListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            emit?: {
                (event: "close"): boolean;
                (event: "data", chunk: any): boolean;
                (event: "end"): boolean;
                (event: "readable"): boolean;
                (event: "error", err: Error): boolean;
                (event: string | symbol, ...args: any[]): boolean;
            };
            on?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            once?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            prependOnceListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            removeListener?: {
                (event: "close", listener: () => void): import("stream").Readable;
                (event: "data", listener: (chunk: any) => void): import("stream").Readable;
                (event: "end", listener: () => void): import("stream").Readable;
                (event: "readable", listener: () => void): import("stream").Readable;
                (event: "error", listener: (err: Error) => void): import("stream").Readable;
                (event: string | symbol, listener: (...args: any[]) => void): import("stream").Readable;
            };
            pipe?: <T_1 extends NodeJS.WritableStream>(destination: T_1, options?: {
                end?: boolean;
            }) => T_1;
            off?: (event: string | symbol, listener: (...args: any[]) => void) => import("stream").Readable;
            removeAllListeners?: (event?: string | symbol) => import("stream").Readable;
            setMaxListeners?: (n: number) => import("stream").Readable;
            getMaxListeners?: () => number;
            listeners?: (event: string | symbol) => Function[];
            rawListeners?: (event: string | symbol) => Function[];
            eventNames?: () => (string | symbol)[];
            listenerCount?: (type: string | symbol) => number;
        })?];
        readonly killed?: boolean;
        readonly pid?: number;
        readonly connected?: boolean;
        kill?: (signal?: number | "SIGABRT" | "SIGALRM" | "SIGBUS" | "SIGCHLD" | "SIGCONT" | "SIGFPE" | "SIGHUP" | "SIGILL" | "SIGINT" | "SIGIO" | "SIGIOT" | "SIGKILL" | "SIGPIPE" | "SIGPOLL" | "SIGPROF" | "SIGPWR" | "SIGQUIT" | "SIGSEGV" | "SIGSTKFLT" | "SIGSTOP" | "SIGSYS" | "SIGTERM" | "SIGTRAP" | "SIGTSTP" | "SIGTTIN" | "SIGTTOU" | "SIGUNUSED" | "SIGURG" | "SIGUSR1" | "SIGUSR2" | "SIGVTALRM" | "SIGWINCH" | "SIGXCPU" | "SIGXFSZ" | "SIGBREAK" | "SIGLOST" | "SIGINFO") => void;
        send?: {
            (message: any, callback?: (error: Error) => void): boolean;
            (message: any, sendHandle?: import("net").Socket | import("net").Server, callback?: (error: Error) => void): boolean;
            (message: any, sendHandle?: import("net").Socket | import("net").Server, options?: import("child_process").MessageOptions, callback?: (error: Error) => void): boolean;
        };
        disconnect?: () => void;
        unref?: () => void;
        ref?: () => void;
        addListener?: {
            (event: string, listener: (...args: any[]) => void): import("child_process").ChildProcess;
            (event: "close", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "disconnect", listener: () => void): import("child_process").ChildProcess;
            (event: "error", listener: (err: Error) => void): import("child_process").ChildProcess;
            (event: "exit", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "message", listener: (message: any, sendHandle: import("net").Socket | import("net").Server) => void): import("child_process").ChildProcess;
        };
        emit?: {
            (event: string | symbol, ...args: any[]): boolean;
            (event: "close", code: number, signal: NodeJS.Signals): boolean;
            (event: "disconnect"): boolean;
            (event: "error", err: Error): boolean;
            (event: "exit", code: number, signal: NodeJS.Signals): boolean;
            (event: "message", message: any, sendHandle: import("net").Socket | import("net").Server): boolean;
        };
        on?: {
            (event: string, listener: (...args: any[]) => void): import("child_process").ChildProcess;
            (event: "close", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "disconnect", listener: () => void): import("child_process").ChildProcess;
            (event: "error", listener: (err: Error) => void): import("child_process").ChildProcess;
            (event: "exit", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "message", listener: (message: any, sendHandle: import("net").Socket | import("net").Server) => void): import("child_process").ChildProcess;
        };
        once?: {
            (event: string, listener: (...args: any[]) => void): import("child_process").ChildProcess;
            (event: "close", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "disconnect", listener: () => void): import("child_process").ChildProcess;
            (event: "error", listener: (err: Error) => void): import("child_process").ChildProcess;
            (event: "exit", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "message", listener: (message: any, sendHandle: import("net").Socket | import("net").Server) => void): import("child_process").ChildProcess;
        };
        prependListener?: {
            (event: string, listener: (...args: any[]) => void): import("child_process").ChildProcess;
            (event: "close", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "disconnect", listener: () => void): import("child_process").ChildProcess;
            (event: "error", listener: (err: Error) => void): import("child_process").ChildProcess;
            (event: "exit", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "message", listener: (message: any, sendHandle: import("net").Socket | import("net").Server) => void): import("child_process").ChildProcess;
        };
        prependOnceListener?: {
            (event: string, listener: (...args: any[]) => void): import("child_process").ChildProcess;
            (event: "close", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "disconnect", listener: () => void): import("child_process").ChildProcess;
            (event: "error", listener: (err: Error) => void): import("child_process").ChildProcess;
            (event: "exit", listener: (code: number, signal: NodeJS.Signals) => void): import("child_process").ChildProcess;
            (event: "message", listener: (message: any, sendHandle: import("net").Socket | import("net").Server) => void): import("child_process").ChildProcess;
        };
        removeListener?: (event: string | symbol, listener: (...args: any[]) => void) => import("child_process").ChildProcess;
        off?: (event: string | symbol, listener: (...args: any[]) => void) => import("child_process").ChildProcess;
        removeAllListeners?: (event?: string | symbol) => import("child_process").ChildProcess;
        setMaxListeners?: (n: number) => import("child_process").ChildProcess;
        getMaxListeners?: () => number;
        listeners?: (event: string | symbol) => Function[];
        rawListeners?: (event: string | symbol) => Function[];
        eventNames?: () => (string | symbol)[];
        listenerCount?: (type: string | symbol) => number;
    };
    status?: Agent.Status;
    currentMoveCommands?: string[];
    _currentMovePromise?: {
        then?: <TResult1 = void, TResult2 = never>(onfulfilled?: (value: void) => TResult1 | PromiseLike<TResult1>, onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>) => Promise<TResult1 | TResult2>;
        catch?: <TResult = never>(onrejected?: (reason: any) => TResult | PromiseLike<TResult>) => Promise<void | TResult>;
        finally?: (onfinally?: () => void) => Promise<void>;
    };
    _currentMoveResolve?: Function;
    _currentMoveReject?: Function;
    agentTimeStep?: number;
    _clearTimer?: Function;
    _install?: () => Promise<void>;
    _compile?: () => Promise<void>;
    _spawn?: () => Promise<import("child_process").ChildProcess>;
    _spawnProcess?: (command: string, args: string[]) => Promise<import("child_process").ChildProcess>;
    isTerminated?: () => boolean;
    _terminate?: () => Promise<void>;
    _disallowCommands?: () => void;
    _allowCommands?: () => void;
    isAllowedToSendCommands?: () => boolean;
    _setTimeout?: (fn: Function, delay: number, ...args: any[]) => void;
    _finishMove?: () => void;
    _setupMove?: () => void;
};
export default router;
