import { Tournament, Player } from '../../../../../Tournament';
declare const router: import("express-serve-static-core").Router;
/**
 * Picks out relevant fields for a tournament
 */
export declare const pickTournament: (t: Tournament) => {
    configs?: {
        defaultMatchConfigs?: {
            [x: string]: any;
            name?: string;
            loggingLevel?: import("../../../../..").Logger.LEVEL;
            engineOptions?: {
                commandStreamType?: import("../../../../..").MatchEngine.COMMAND_STREAM_TYPE;
                commandDelimiter?: string;
                commandFinishSymbol?: string;
                commandFinishPolicy?: import("../../../../..").MatchEngine.COMMAND_FINISH_POLICIES;
                commandLines?: {
                    max?: number;
                    waitForNewline?: boolean;
                };
                noStdErr?: boolean;
                timeout?: {
                    active?: boolean;
                    max?: number;
                    timeoutCallback?: (agent: import("../../../../..").Agent, match: import("../../../../..").Match, engineOptions: import("../../../../..").MatchEngine.EngineOptions) => void;
                };
                memory?: {
                    active?: boolean;
                    limit?: number;
                    memoryCallback?: (agent: import("../../../../..").Agent, match: import("../../../../..").Match, engineOptions: import("../../../../..").MatchEngine.EngineOptions) => void;
                    checkRate?: number;
                    usePs?: boolean;
                };
            };
            secureMode?: boolean;
            agentOptions?: {
                name?: string;
                secureMode?: boolean;
                id?: number;
                tournamentID?: {
                    readonly id?: string;
                    name?: string;
                    username?: string;
                };
                loggingLevel?: import("../../../../..").Logger.LEVEL;
                maxInstallTime?: number;
                maxCompileTime?: number;
                compileCommands?: {
                    [x: string]: string[];
                };
                runCommands?: {
                    [x: string]: string[];
                };
            };
            storeReplay?: boolean;
            storeReplayDirectory?: string;
        };
        type?: Tournament.Type;
        rankSystem?: Tournament.RankSystem;
        resultHandler?: (results: any) => any;
        rankSystemConfigs?: any;
        loggingLevel?: import("../../../../..").Logger.LEVEL;
        name?: string;
        tournamentConfigs?: any;
        agentsPerMatch?: number[];
        consoleDisplay?: boolean;
        id?: string;
    };
    matches?: {
        clear?: () => void;
        delete?: (key: string) => boolean;
        forEach?: (callbackfn: (value: import("../../../../..").Match, key: string, map: Map<string, import("../../../../..").Match>) => void, thisArg?: any) => void;
        get?: (key: string) => import("../../../../..").Match;
        has?: (key: string) => boolean;
        set?: (key: string, value: import("../../../../..").Match) => Map<string, import("../../../../..").Match>;
        readonly size?: number;
        entries?: () => IterableIterator<[string, import("../../../../..").Match]>;
        keys?: () => IterableIterator<string>;
        values?: () => IterableIterator<import("../../../../..").Match>;
    };
    matchQueue?: {
        anonymous?: boolean;
        username?: string;
        botDirPath?: string;
        botkey?: string;
        disabled?: boolean;
        zipFile?: string;
        tournamentID?: {
            readonly id?: string;
            name?: string;
            username?: string;
        };
        file?: string;
    }[][];
    status?: Tournament.Status;
    state?: {
        results?: any[];
        playerStats?: {
            clear?: () => void;
            delete?: (key: string) => boolean;
            forEach?: (callbackfn: (value: Tournament.PlayerStatBase, key: string, map: Map<string, Tournament.PlayerStatBase>) => void, thisArg?: any) => void;
            get?: (key: string) => Tournament.PlayerStatBase;
            has?: (key: string) => boolean;
            set?: (key: string, value: Tournament.PlayerStatBase) => Map<string, Tournament.PlayerStatBase>;
            readonly size?: number;
            entries?: () => IterableIterator<[string, Tournament.PlayerStatBase]>;
            keys?: () => IterableIterator<string>;
            values?: () => IterableIterator<Tournament.PlayerStatBase>;
        };
    };
    log?: {
        identifier?: string;
        identifierColor?: import("colors").Color;
        level?: import("../../../../..").Logger.LEVEL;
        getIdentifier?: () => string;
        bar?: (type?: string) => string;
        importantBar?: () => void;
        important?: (...message: any[]) => void;
        systemIObar?: () => void;
        systemIO?: (...message: any[]) => void;
        systembar2?: () => void;
        system2?: (...message: any[]) => void;
        systembar?: () => void;
        system?: (...message: any[]) => void;
        detailbar?: () => void;
        detail?: (...message: any[]) => void;
        infobar?: () => void;
        info?: (...message: any[]) => void;
        warnbar?: () => void;
        warn?: (...message: any[]) => void;
        errorbar?: () => void;
        error?: (...message: any[]) => void;
    };
    competitors?: {
        clear?: () => void;
        delete?: (key: string) => boolean;
        forEach?: (callbackfn: (value: Player, key: string, map: Map<string, Player>) => void, thisArg?: any) => void;
        get?: (key: string) => Player;
        has?: (key: string) => boolean;
        set?: (key: string, value: Player) => Map<string, Player>;
        readonly size?: number;
        entries?: () => IterableIterator<[string, Player]>;
        keys?: () => IterableIterator<string>;
        values?: () => IterableIterator<Player>;
    };
    anonymousCompetitors?: {
        clear?: () => void;
        delete?: (key: string) => boolean;
        forEach?: (callbackfn: (value: Player, key: string, map: Map<string, Player>) => void, thisArg?: any) => void;
        get?: (key: string) => Player;
        has?: (key: string) => boolean;
        set?: (key: string, value: Player) => Map<string, Player>;
        readonly size?: number;
        entries?: () => IterableIterator<[string, Player]>;
        keys?: () => IterableIterator<string>;
        values?: () => IterableIterator<Player>;
    };
    dimension?: {
        matches?: {
            clear?: () => void;
            delete?: (key: string) => boolean;
            forEach?: (callbackfn: (value: import("../../../../..").Match, key: string, map: Map<string, import("../../../../..").Match>) => void, thisArg?: any) => void;
            get?: (key: string) => import("../../../../..").Match;
            has?: (key: string) => boolean;
            set?: (key: string, value: import("../../../../..").Match) => Map<string, import("../../../../..").Match>;
            readonly size?: number;
            entries?: () => IterableIterator<[string, import("../../../../..").Match]>;
            keys?: () => IterableIterator<string>;
            values?: () => IterableIterator<import("../../../../..").Match>;
        };
        tournaments?: {
            clear?: () => void;
            delete?: (key: string) => boolean;
            forEach?: (callbackfn: (value: Tournament, key: string, map: Map<string, Tournament>) => void, thisArg?: any) => void;
            get?: (key: string) => Tournament;
            has?: (key: string) => boolean;
            set?: (key: string, value: Tournament) => Map<string, Tournament>;
            readonly size?: number;
            entries?: () => IterableIterator<[string, Tournament]>;
            keys?: () => IterableIterator<string>;
            values?: () => IterableIterator<Tournament>;
        };
        name?: string;
        id?: string;
        log?: {
            identifier?: string;
            identifierColor?: import("colors").Color;
            level?: import("../../../../..").Logger.LEVEL;
            getIdentifier?: () => string;
            bar?: (type?: string) => string;
            importantBar?: () => void;
            important?: (...message: any[]) => void;
            systemIObar?: () => void;
            systemIO?: (...message: any[]) => void;
            systembar2?: () => void;
            system2?: (...message: any[]) => void;
            systembar?: () => void;
            system?: (...message: any[]) => void;
            detailbar?: () => void;
            detail?: (...message: any[]) => void;
            infobar?: () => void;
            info?: (...message: any[]) => void;
            warnbar?: () => void;
            warn?: (...message: any[]) => void;
            errorbar?: () => void;
            error?: (...message: any[]) => void;
        };
        databasePlugin?: {
            configs?: {
                saveMatches?: boolean;
                saveTournamentMatches?: boolean;
            };
            initialize?: (dimension: import("../../../../..").DimensionType) => Promise<any>;
            storeMatch?: (match: import("../../../../..").Match, governID: string) => Promise<any>;
            getMatch?: (id: string) => Promise<any>;
            getRanks?: (tournament: Tournament.Ladder, offset: number, limit: number) => Promise<Tournament.Ladder.PlayerStat[]>;
            loginUser?: (username: string, password: string) => Promise<any>;
            registerUser?: (username: string, password: string, userData?: any) => Promise<any>;
            verifyToken?: (jwt: string) => Promise<any>;
            deleteUser?: (usernameOrID: string) => Promise<any>;
            updateUser?: (usernameOrID: string, update: Partial<import("../../../../../Plugin/Database").Database.User>) => Promise<any>;
            getUser?: (usernameOrID: string, publicView?: boolean) => Promise<import("../../../../../Plugin/Database").Database.User>;
            getUsersInTournament?: (tournamentKeyName: string, offset: number, limit: number) => Promise<import("../../../../../Plugin/Database").Database.User[]>;
            isAdmin?: (user: import("../../../../../Plugin/Database").Database.PublicUser) => boolean;
            getPlayerMatches?: (playerID: string, governID: string, offset: number, limit: number, order: number) => Promise<import("../../../../..").Match[]>;
            getTournamentConfigs?: (tournamentID: string) => Promise<{
                configs: Tournament.TournamentConfigsBase;
                status: Tournament.Status;
            }>;
            getTournamentConfigsModificationDate?: (tournamentID: string) => Promise<Date>;
            storeTournamentConfigs?: (tournamentID: string, tournamentConfigs: Tournament.TournamentConfigsBase, status: Tournament.Status) => Promise<void>;
            name?: string;
            type?: import("../../../../..").Plugin.Type;
            manipulate?: (dimension: import("../../../../..").DimensionType) => Promise<void>;
        };
        storagePlugin?: {
            configs?: {};
            initialize?: (dimension: import("../../../../..").DimensionType) => Promise<any>;
            uploadTournamentFile?: (file: string, user: import("../../../../../Plugin/Database").Database.User, tournament: Tournament) => Promise<string>;
            uploadUserFile?: (file: string, userID: string, destinationName: string) => Promise<string>;
            upload?: (file: string, destinationName: string) => Promise<string>;
            download?: (key: string, destination: string) => Promise<any>;
            getDownloadURL?: (key: string) => Promise<string>;
            name?: string;
            type?: import("../../../../..").Plugin.Type;
            manipulate?: (dimension: import("../../../../..").DimensionType) => Promise<void>;
        };
        statistics?: {
            tournamentsCreated?: number;
            matchesCreated?: number;
        };
        configs?: {
            name?: string;
            activateStation?: boolean;
            observe?: boolean;
            loggingLevel?: import("../../../../..").Logger.LEVEL;
            defaultMatchConfigs?: {
                [x: string]: any;
                name?: string;
                loggingLevel?: import("../../../../..").Logger.LEVEL;
                engineOptions?: {
                    commandStreamType?: import("../../../../..").MatchEngine.COMMAND_STREAM_TYPE;
                    commandDelimiter?: string;
                    commandFinishSymbol?: string;
                    commandFinishPolicy?: import("../../../../..").MatchEngine.COMMAND_FINISH_POLICIES;
                    commandLines?: {
                        max?: number;
                        waitForNewline?: boolean;
                    };
                    noStdErr?: boolean;
                    timeout?: {
                        active?: boolean;
                        max?: number;
                        timeoutCallback?: (agent: import("../../../../..").Agent, match: import("../../../../..").Match, engineOptions: import("../../../../..").MatchEngine.EngineOptions) => void;
                    };
                    memory?: {
                        active?: boolean;
                        limit?: number;
                        memoryCallback?: (agent: import("../../../../..").Agent, match: import("../../../../..").Match, engineOptions: import("../../../../..").MatchEngine.EngineOptions) => void;
                        checkRate?: number;
                        usePs?: boolean;
                    };
                };
                secureMode?: boolean;
                agentOptions?: {
                    name?: string;
                    secureMode?: boolean;
                    id?: number;
                    tournamentID?: {
                        readonly id?: string;
                        name?: string;
                        username?: string;
                    };
                    loggingLevel?: import("../../../../..").Logger.LEVEL;
                    maxInstallTime?: number;
                    maxCompileTime?: number;
                    compileCommands?: {
                        [x: string]: string[];
                    };
                    runCommands?: {
                        [x: string]: string[];
                    };
                };
                storeReplay?: boolean;
                storeReplayDirectory?: string;
            };
            id?: string;
            secureMode?: boolean;
            backingDatabase?: string;
            backingStorage?: string;
        };
        design?: {
            log?: {
                identifier?: string;
                identifierColor?: import("colors").Color;
                level?: import("../../../../..").Logger.LEVEL;
                getIdentifier?: () => string;
                bar?: (type?: string) => string;
                importantBar?: () => void;
                important?: (...message: any[]) => void;
                systemIObar?: () => void;
                systemIO?: (...message: any[]) => void;
                systembar2?: () => void;
                system2?: (...message: any[]) => void;
                systembar?: () => void;
                system?: (...message: any[]) => void;
                detailbar?: () => void;
                detail?: (...message: any[]) => void;
                infobar?: () => void;
                info?: (...message: any[]) => void;
                warnbar?: () => void;
                warn?: (...message: any[]) => void;
                errorbar?: () => void;
                error?: (...message: any[]) => void;
            };
            name?: {
                [x: number]: string;
                toString?: () => string;
                charAt?: (pos: number) => string;
                charCodeAt?: (index: number) => number;
                concat?: (...strings: string[]) => string;
                indexOf?: (searchString: string, position?: number) => number;
                lastIndexOf?: (searchString: string, position?: number) => number;
                localeCompare?: {
                    (that: string): number;
                    (that: string, locales?: string | string[], options?: Intl.CollatorOptions): number;
                };
                match?: {
                    (regexp: string | RegExp): RegExpMatchArray;
                    (matcher: {
                        [Symbol.match](string: string): RegExpMatchArray;
                    }): RegExpMatchArray;
                };
                replace?: {
                    (searchValue: string | RegExp, replaceValue: string): string;
                    (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
                    (searchValue: {
                        [Symbol.replace](string: string, replaceValue: string): string;
                    }, replaceValue: string): string;
                    (searchValue: {
                        [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
                    }, replacer: (substring: string, ...args: any[]) => string): string;
                };
                search?: {
                    (regexp: string | RegExp): number;
                    (searcher: {
                        [Symbol.search](string: string): number;
                    }): number;
                };
                slice?: (start?: number, end?: number) => string;
                split?: {
                    (separator: string | RegExp, limit?: number): string[];
                    (splitter: {
                        [Symbol.split](string: string, limit?: number): string[];
                    }, limit?: number): string[];
                };
                substring?: (start: number, end?: number) => string;
                toLowerCase?: () => string;
                toLocaleLowerCase?: (locales?: string | string[]) => string;
                toUpperCase?: () => string;
                toLocaleUpperCase?: (locales?: string | string[]) => string;
                trim?: () => string;
                readonly length?: number;
                substr?: (from: number, length?: number) => string;
                valueOf?: () => string;
                codePointAt?: (pos: number) => number;
                includes?: (searchString: string, position?: number) => boolean;
                endsWith?: (searchString: string, endPosition?: number) => boolean;
                normalize?: {
                    (form: "NFC" | "NFD" | "NFKC" | "NFKD"): string;
                    (form?: string): string;
                };
                repeat?: (count: number) => string;
                startsWith?: (searchString: string, position?: number) => boolean;
                anchor?: (name: string) => string;
                big?: () => string;
                blink?: () => string;
                bold?: () => string;
                fixed?: () => string;
                fontcolor?: (color: string) => string;
                fontsize?: {
                    (size: number): string;
                    (size: string): string;
                };
                italics?: () => string;
                link?: (url: string) => string;
                small?: () => string;
                strike?: () => string;
                sub?: () => string;
                sup?: () => string;
                padStart?: (maxLength: number, fillString?: string) => string;
                padEnd?: (maxLength: number, fillString?: string) => string;
                trimLeft?: () => string;
                trimRight?: () => string;
                strip?: string;
                stripColors?: string;
                black?: string;
                red?: string;
                green?: string;
                yellow?: string;
                blue?: string;
                magenta?: string;
                cyan?: string;
                white?: string;
                gray?: string;
                grey?: string;
                bgBlack?: string;
                bgRed?: string;
                bgGreen?: string;
                bgYellow?: string;
                bgBlue?: string;
                bgMagenta?: string;
                bgCyan?: string;
                bgWhite?: string;
                reset?: string;
                dim?: string;
                italic?: string;
                underline?: string;
                inverse?: string;
                hidden?: string;
                strikethrough?: string;
                rainbow?: string;
                zebra?: string;
                america?: string;
                trap?: string;
                random?: string;
                zalgo?: string;
            };
            setLogLevel?: (level: import("../../../../..").Logger.LEVEL) => void;
            getDesignOptions?: () => import("../../../../..").DesignOptions;
            initialize?: (match: import("../../../../..").Match) => Promise<void>;
            update?: (match: import("../../../../..").Match, commands: import("../../../../..").MatchEngine.Command[]) => Promise<import("../../../../..").Match.Status>;
            getResults?: (match: import("../../../../..").Match) => Promise<any>;
        };
        createMatch?: (files: string[] | {
            file: string;
            name: string;
            botkey?: string;
        }[], configs?: {
            [x: string]: any;
            name?: string;
            loggingLevel?: import("../../../../..").Logger.LEVEL;
            engineOptions?: {
                commandStreamType?: import("../../../../..").MatchEngine.COMMAND_STREAM_TYPE;
                commandDelimiter?: string;
                commandFinishSymbol?: string;
                commandFinishPolicy?: import("../../../../..").MatchEngine.COMMAND_FINISH_POLICIES;
                commandLines?: {
                    max?: number;
                    waitForNewline?: boolean;
                };
                noStdErr?: boolean;
                timeout?: {
                    active?: boolean;
                    max?: number;
                    timeoutCallback?: (agent: import("../../../../..").Agent, match: import("../../../../..").Match, engineOptions: import("../../../../..").MatchEngine.EngineOptions) => void;
                };
                memory?: {
                    active?: boolean;
                    limit?: number;
                    memoryCallback?: (agent: import("../../../../..").Agent, match: import("../../../../..").Match, engineOptions: import("../../../../..").MatchEngine.EngineOptions) => void;
                    checkRate?: number;
                    usePs?: boolean;
                };
            };
            secureMode?: boolean;
            agentOptions?: {
                name?: string;
                secureMode?: boolean;
                id?: number;
                tournamentID?: {
                    readonly id?: string;
                    name?: string;
                    username?: string;
                };
                loggingLevel?: import("../../../../..").Logger.LEVEL;
                maxInstallTime?: number;
                maxCompileTime?: number;
                compileCommands?: {
                    [x: string]: string[];
                };
                runCommands?: {
                    [x: string]: string[];
                };
            };
            storeReplay?: boolean;
            storeReplayDirectory?: string;
        }) => Promise<import("../../../../..").Match>;
        runMatch?: (files: string[] | {
            file: string;
            name: string;
            botkey?: string;
        }[], configs?: {
            [x: string]: any;
            name?: string;
            loggingLevel?: import("../../../../..").Logger.LEVEL;
            engineOptions?: {
                commandStreamType?: import("../../../../..").MatchEngine.COMMAND_STREAM_TYPE;
                commandDelimiter?: string;
                commandFinishSymbol?: string;
                commandFinishPolicy?: import("../../../../..").MatchEngine.COMMAND_FINISH_POLICIES;
                commandLines?: {
                    max?: number;
                    waitForNewline?: boolean;
                };
                noStdErr?: boolean;
                timeout?: {
                    active?: boolean;
                    max?: number;
                    timeoutCallback?: (agent: import("../../../../..").Agent, match: import("../../../../..").Match, engineOptions: import("../../../../..").MatchEngine.EngineOptions) => void;
                };
                memory?: {
                    active?: boolean;
                    limit?: number;
                    memoryCallback?: (agent: import("../../../../..").Agent, match: import("../../../../..").Match, engineOptions: import("../../../../..").MatchEngine.EngineOptions) => void;
                    checkRate?: number;
                    usePs?: boolean;
                };
            };
            secureMode?: boolean;
            agentOptions?: {
                name?: string;
                secureMode?: boolean;
                id?: number;
                tournamentID?: {
                    readonly id?: string;
                    name?: string;
                    username?: string;
                };
                loggingLevel?: import("../../../../..").Logger.LEVEL;
                maxInstallTime?: number;
                maxCompileTime?: number;
                compileCommands?: {
                    [x: string]: string[];
                };
                runCommands?: {
                    [x: string]: string[];
                };
            };
            storeReplay?: boolean;
            storeReplayDirectory?: string;
        }) => Promise<any>;
        createTournament?: (files: string[] | {
            file: string;
            name: string;
            existingId?: string;
        }[], configs: Tournament.TournamentConfigsBase) => Tournament;
        getStation?: () => import("../../../..").Station;
        removeMatch?: (matchID: string) => Promise<boolean>;
        use?: (plugin: import("../../../../..").Plugin) => Promise<void>;
        hasDatabase?: () => boolean;
        hasStorage?: () => boolean;
    };
    id?: string;
    name?: string;
    initialAddPlayerPromises?: {
        then?: <TResult1 = any, TResult2 = never>(onfulfilled?: (value: any) => TResult1 | PromiseLike<TResult1>, onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>) => Promise<TResult1 | TResult2>;
        catch?: <TResult = never>(onrejected?: (reason: any) => TResult | PromiseLike<TResult>) => Promise<any>;
        finally?: (onfinally?: () => void) => Promise<any>;
    }[];
    addplayer?: (file: string | {
        file: string;
        name: string;
        zipFile?: string;
        botdir?: string;
        botkey?: string;
    }, existingID?: string) => Promise<Player>;
    internalAddPlayer?: (player: Player) => void;
    generateNextTournamentIDString?: () => string;
    run?: (configs?: {
        defaultMatchConfigs?: {
            [x: string]: any;
            name?: string;
            loggingLevel?: import("../../../../..").Logger.LEVEL;
            engineOptions?: {
                commandStreamType?: import("../../../../..").MatchEngine.COMMAND_STREAM_TYPE;
                commandDelimiter?: string;
                commandFinishSymbol?: string;
                commandFinishPolicy?: import("../../../../..").MatchEngine.COMMAND_FINISH_POLICIES;
                commandLines?: {
                    max?: number;
                    waitForNewline?: boolean;
                };
                noStdErr?: boolean;
                timeout?: {
                    active?: boolean;
                    max?: number;
                    timeoutCallback?: (agent: import("../../../../..").Agent, match: import("../../../../..").Match, engineOptions: import("../../../../..").MatchEngine.EngineOptions) => void;
                };
                memory?: {
                    active?: boolean;
                    limit?: number;
                    memoryCallback?: (agent: import("../../../../..").Agent, match: import("../../../../..").Match, engineOptions: import("../../../../..").MatchEngine.EngineOptions) => void;
                    checkRate?: number;
                    usePs?: boolean;
                };
            };
            secureMode?: boolean;
            agentOptions?: {
                name?: string;
                secureMode?: boolean;
                id?: number;
                tournamentID?: {
                    readonly id?: string;
                    name?: string;
                    username?: string;
                };
                loggingLevel?: import("../../../../..").Logger.LEVEL;
                maxInstallTime?: number;
                maxCompileTime?: number;
                compileCommands?: {
                    [x: string]: string[];
                };
                runCommands?: {
                    [x: string]: string[];
                };
            };
            storeReplay?: boolean;
            storeReplayDirectory?: string;
        };
        type?: Tournament.Type;
        rankSystem?: Tournament.RankSystem;
        resultHandler?: (results: any) => any;
        rankSystemConfigs?: any;
        loggingLevel?: import("../../../../..").Logger.LEVEL;
        name?: string;
        tournamentConfigs?: any;
        agentsPerMatch?: number[];
        consoleDisplay?: boolean;
        id?: string;
    }, master?: boolean) => Promise<any>;
    stop?: (master?: boolean) => Promise<any>;
    resume?: (master?: boolean) => Promise<any>;
    getRankings?: (offset?: number, limit?: number) => any;
    updatePlayer?: (player: Player, oldname: string, oldfile: string) => Promise<void>;
    disablePlayer?: (playerID: string) => Promise<void>;
    removePlayer?: (playerID: string) => Promise<void>;
    setConfigs?: (configs: {
        defaultMatchConfigs?: {
            [x: string]: any;
            name?: string;
            loggingLevel?: import("../../../../..").Logger.LEVEL;
            engineOptions?: {
                commandStreamType?: import("../../../../..").MatchEngine.COMMAND_STREAM_TYPE;
                commandDelimiter?: string;
                commandFinishSymbol?: string;
                commandFinishPolicy?: import("../../../../..").MatchEngine.COMMAND_FINISH_POLICIES;
                commandLines?: {
                    max?: number;
                    waitForNewline?: boolean;
                };
                noStdErr?: boolean;
                timeout?: {
                    active?: boolean;
                    max?: number;
                    timeoutCallback?: (agent: import("../../../../..").Agent, match: import("../../../../..").Match, engineOptions: import("../../../../..").MatchEngine.EngineOptions) => void;
                };
                memory?: {
                    active?: boolean;
                    limit?: number;
                    memoryCallback?: (agent: import("../../../../..").Agent, match: import("../../../../..").Match, engineOptions: import("../../../../..").MatchEngine.EngineOptions) => void;
                    checkRate?: number;
                    usePs?: boolean;
                };
            };
            secureMode?: boolean;
            agentOptions?: {
                name?: string;
                secureMode?: boolean;
                id?: number;
                tournamentID?: {
                    readonly id?: string;
                    name?: string;
                    username?: string;
                };
                loggingLevel?: import("../../../../..").Logger.LEVEL;
                maxInstallTime?: number;
                maxCompileTime?: number;
                compileCommands?: {
                    [x: string]: string[];
                };
                runCommands?: {
                    [x: string]: string[];
                };
            };
            storeReplay?: boolean;
            storeReplayDirectory?: string;
        };
        type?: Tournament.Type;
        rankSystem?: Tournament.RankSystem;
        resultHandler?: (results: any) => any;
        rankSystemConfigs?: any;
        loggingLevel?: import("../../../../..").Logger.LEVEL;
        name?: string;
        tournamentConfigs?: any;
        agentsPerMatch?: number[];
        consoleDisplay?: boolean;
        id?: string;
    }) => void;
    getConfigs?: () => Tournament.TournamentConfigsBase;
    removeMatch?: (matchID: string) => Promise<boolean>;
    destroy?: () => Promise<void>;
    getSafeName?: () => string;
    getKeyName?: () => string;
    getPlayerStat?: (id: string) => Promise<{
        user: import("../../../../../Plugin/Database").Database.User;
        playerStat: Tournament.PlayerStatBase;
    }>;
};
export default router;
