"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var os_1 = __importDefault(require("os"));
var child_process_1 = require("child_process");
var pidusage_1 = __importDefault(require("pidusage"));
// Import utilities
var DeepCopy_1 = require("../utils/DeepCopy");
var DeepMerge_1 = require("../utils/DeepMerge");
var DimensionError_1 = require("../DimensionError");
var Logger_1 = require("../Logger");
var Agent_1 = require("../Agent");
var Match_1 = require("../Match");
var System_1 = require("../utils/System");
/**
 * The Match Engine that takes a {@link Design} and its specified {@link EngineOptions} to form the backend
 * for running matches with agents.
 */
var MatchEngine = /** @class */ (function () {
    /**
     * Match engine constructor
     * @param design - the design to use
     * @param loggingLevel - the logging level for this engine
     */
    function MatchEngine(design, loggingLevel) {
        /** Logger */
        this.log = new Logger_1.Logger();
        /**
         * A coordination signal to ensure that all processes are indeed killed due to asynchronous initialization of agents
         * There is a race condition when a tournament/match is being destroyed and while every match is being destroyed, some
         * matches are in the initialization stage where they call the engine's initialize function. As a result, when we
         * send a match destroy signal, we spawn some processes and haven't spawned some others for the agents. As a result,
         * all processes eventually get spawned but not all are cleaned up and killed.
         */
        this.killOffSignal = false;
        this.design = design;
        this.engineOptions = DeepCopy_1.deepCopy(this.design.getDesignOptions().engineOptions);
        this.overrideOptions = DeepCopy_1.deepCopy(this.design.getDesignOptions().override);
        this.log.identifier = "Engine";
        this.setLogLevel(loggingLevel);
    }
    /** Set log level */
    MatchEngine.prototype.setLogLevel = function (loggingLevel) {
        this.log.level = loggingLevel;
    };
    /** Get the engine options */
    MatchEngine.prototype.getEngineOptions = function () {
        return this.engineOptions;
    };
    /** Set the engine options */
    MatchEngine.prototype.setEngineOptions = function (newOptions) {
        if (newOptions === void 0) { newOptions = {}; }
        this.engineOptions = DeepMerge_1.deepMerge(this.engineOptions, newOptions);
    };
    /**
     * Starts up the engine by intializing processes for all the agents and setting some variables for a match
     * @param agents - The agents involved to be setup for the given match
     * @param match - The match to initialize
     * @returns a promise that resolves once succesfully initialized
     */
    MatchEngine.prototype.initialize = function (agents, match) {
        return __awaiter(this, void 0, void 0, function () {
            var agentSetupPromises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.log.systembar();
                        agentSetupPromises = [];
                        match.agents.forEach(function (agent, index) {
                            agentSetupPromises.push(_this.initializeAgent(agent, match));
                        }, this);
                        return [4 /*yield*/, Promise.all(agentSetupPromises)];
                    case 1:
                        _a.sent();
                        this.log.system('FINISHED INITIALIZATION OF PROCESSES\n');
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns a promise that resolves once the process succesfully spawned and rejects if error occurs
     * @param pid - process id to check
     */
    MatchEngine.prototype.spawnedPromise = function (pid) {
        return __awaiter(this, void 0, void 0, function () {
            var refreshRate, checkSpawn, setSpawnCheckTimer;
            return __generator(this, function (_a) {
                refreshRate = 10;
                checkSpawn = function () {
                    return new Promise(function (resolve, reject) {
                        child_process_1.exec("ps -p " + pid, function (err, stdout) {
                            if (err)
                                reject(err);
                            if (stdout.split('\n').length > 2) {
                                resolve();
                            }
                            reject();
                        });
                    });
                };
                setSpawnCheckTimer = function (resolve, reject) {
                    setTimeout(function () {
                        checkSpawn().then(function () {
                            resolve();
                        }).catch(function (err) {
                            if (err)
                                reject(err);
                            setSpawnCheckTimer(resolve, reject);
                        });
                    }, refreshRate);
                };
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        setSpawnCheckTimer(resolve, reject);
                    })];
            });
        });
    };
    /**
     * Initializes a single agent, called by {@link initialize}
     * @param agent - agent to initialize
     * @param match - match to initialize in
     */
    MatchEngine.prototype.initializeAgent = function (agent, match) {
        return __awaiter(this, void 0, void 0, function () {
            var p, checkAgentMemoryUsage_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.log.system("Setting up and spawning " + agent.name + (" | Command: " + agent.cmd + " " + agent.src));
                        // wait for install step
                        return [4 /*yield*/, agent._install()];
                    case 1:
                        // wait for install step
                        _a.sent();
                        this.log.system('Succesfully ran install step for agent ' + agent.id);
                        // wait for compilation step
                        return [4 /*yield*/, agent._compile()];
                    case 2:
                        // wait for compilation step
                        _a.sent();
                        this.log.system('Succesfully ran compile step for agent ' + agent.id);
                        return [4 /*yield*/, agent._spawn()];
                    case 3:
                        p = _a.sent();
                        this.log.system('Spawned agent ' + agent.id);
                        // add listener for memory limit exceeded
                        p.on(MatchEngine.AGENT_EVENTS.EXCEED_MEMORY_LIMIT, function (stat) {
                            _this.engineOptions.memory.memoryCallback(agent, match, _this.engineOptions);
                        });
                        // add listener for timeouts
                        p.on(MatchEngine.AGENT_EVENTS.TIMEOUT, function () {
                            _this.engineOptions.timeout.timeoutCallback(agent, match, _this.engineOptions);
                        });
                        match.idToAgentsMap.set(agent.id, agent);
                        // set agent status as running
                        agent.status = Agent_1.Agent.Status.RUNNING;
                        // handler for stdout of Agent processes. Stores their output commands and resolves move promises
                        p.stdout.on('readable', function () {
                            var data;
                            while (data = p.stdout.read()) {
                                // split chunks into line by line and handle each line of commands
                                var strs = ("" + data).split('\n');
                                // first store data into a buffer and process later if no newline character is detected
                                // if final char in the strs array is not '', then \n is not at the end
                                if (_this.engineOptions.commandLines.waitForNewline && strs.length >= 1 && strs[strs.length - 1] != '') {
                                    // using split with \n should make any existing final \n character to be set as '' in strs array
                                    // if there is an existing buffer from the previous 'readable' event, 
                                    // concat it to the first strs element as it belongs with that
                                    if (strs.length > 1) {
                                        // greater than 1 implies the first strs element is delimited by a \n
                                        strs[0] = agent._buffer.join('').concat(strs[0]);
                                        agent._buffer = [];
                                    }
                                    for (var i = 0; i < strs.length - 1; i++) {
                                        if (strs[i] === '')
                                            continue;
                                        if (agent.isAllowedToSendCommands()) {
                                            _this.handleCommmand(agent, strs[i]);
                                        }
                                    }
                                    // push whatever didn't have a newline into buffer
                                    agent._buffer.push(strs[strs.length - 1]);
                                }
                                else {
                                    if (strs.length > 1) {
                                        // greater than 1 implies the first strs element is delimited by a \n
                                        strs[0] = agent._buffer.join('').concat(strs[0]);
                                        agent._buffer = [];
                                    }
                                    // this.log.systemIO(`${agent.name} - stdout: ${strs}`);
                                    for (var i = 0; i < strs.length; i++) {
                                        if (strs[i] === '')
                                            continue;
                                        if (agent.isAllowedToSendCommands()) {
                                            _this.handleCommmand(agent, strs[i]);
                                        }
                                    }
                                }
                            }
                        });
                        // log stderr from agents to this stderr if option active
                        if (!this.engineOptions.noStdErr) {
                            p.stderr.on('data', function (data) {
                                _this.log.error(agent.id + ": " + data.slice(0, data.length - 1));
                            });
                        }
                        // when process closes, print message
                        p.on('close', function (code) {
                            // terminate agent with API if it hasn't been marked as terminated yet, indicating process likely exited
                            // prematurely
                            if (!agent.isTerminated()) {
                                _this.kill(agent);
                            }
                            _this.log.system(agent.name + " | id: " + agent.id + " - exited with code " + code);
                        });
                        // store process
                        agent.process = p;
                        if (this.engineOptions.memory.active) {
                            checkAgentMemoryUsage_1 = function () {
                                // setting { maxage: 0 } because otherwise pidusage leaves interval "memory leaks" and process doesn't exit fast
                                if (System_1.processIsRunning(agent.process.pid)) {
                                    pidusage_1.default(agent.process.pid, { maxage: 0, usePs: _this.engineOptions.memory.usePs }).then(function (stat) {
                                        if (stat.memory > _this.engineOptions.memory.limit) {
                                            agent.process.emit(MatchEngine.AGENT_EVENTS.EXCEED_MEMORY_LIMIT, stat);
                                        }
                                    }).catch(function (err) {
                                        _this.log.warn(err);
                                    });
                                }
                            };
                            checkAgentMemoryUsage_1();
                            agent.memoryWatchInterval = setInterval(function () {
                                checkAgentMemoryUsage_1();
                            }, this.engineOptions.memory.checkRate);
                        }
                        // this is for handling a race condition explained in the comments of this.killOffSignal
                        // Briefly, sometimes agent process isn't stored yet during initialization and doesn't get killed as a result
                        if (this.killOffSignal) {
                            this.kill(agent);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Handles partial stdout from an agent
     * @param agent - the agent to process the command for
     * @param str - the string the agent sent
     */
    MatchEngine.prototype.handleCommmand = function (agent, str) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // TODO: Implement parallel command stream type
                if (this.engineOptions.commandStreamType === MatchEngine.COMMAND_STREAM_TYPE.SEQUENTIAL) {
                    // IF SEQUENTIAL, we wait for each unit to finish their move and output their commands
                    switch (this.engineOptions.commandFinishPolicy) {
                        case MatchEngine.COMMAND_FINISH_POLICIES.FINISH_SYMBOL:
                            // if we receive the symbol representing that the agent is done with output and now awaits for updates
                            if ("" + str === this.engineOptions.commandFinishSymbol) {
                                agent._finishMove();
                            }
                            else {
                                agent.currentMoveCommands.push(str);
                            }
                            break;
                        case MatchEngine.COMMAND_FINISH_POLICIES.LINE_COUNT:
                            // if we receive the finish symbol, we mark agent as done with output (finishes their move prematurely)
                            if ("" + str === this.engineOptions.commandFinishSymbol) {
                                agent._finishMove();
                            }
                            // only log command if max isnt reached
                            else if (agent.currentMoveCommands.length < this.engineOptions.commandLines.max - 1) {
                                agent.currentMoveCommands.push(str);
                            }
                            // else if on final command before reaching max, push final command and resolve
                            else if (agent.currentMoveCommands.length == this.engineOptions.commandLines.max - 1) {
                                agent._finishMove();
                                agent.currentMoveCommands.push(str);
                            }
                            break;
                        case MatchEngine.COMMAND_FINISH_POLICIES.CUSTOM:
                            // TODO: Not implemented yet
                            throw new DimensionError_1.NotSupportedError('Custom command finish policies are not allowed yet');
                            break;
                    }
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Attempts to gracefully and synchronously stop a match's agents
     * @param match - the match to stop
     */
    MatchEngine.prototype.stop = function (match) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                match.agents.forEach(function (agent) {
                    agent.process.kill('SIGSTOP');
                    agent.status = Agent_1.Agent.Status.STOPPED;
                });
                this.log.system('Stopped all agents');
                return [2 /*return*/];
            });
        });
    };
    /**
     * Attempts to gracefully and synchronously resume a previously stopped match
     * @param match - the match to resume
     */
    MatchEngine.prototype.resume = function (match) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                match.agents.forEach(function (agent) {
                    agent._allowCommands();
                    agent.process.kill('SIGCONT');
                    agent.status = Agent_1.Agent.Status.RUNNING;
                });
                this.log.system('Resumed all agents');
                return [2 /*return*/];
            });
        });
    };
    /**
     * Kills all agents and processes from a match and cleans up. Kills any game processes as well. Shouldn't be used
     * for custom design based matches. Called by {@link Match}
     *
     * @param match - the match to kill all agents in and clean up
     */
    MatchEngine.prototype.killAndClean = function (match) {
        return __awaiter(this, void 0, void 0, function () {
            var cleanUpPromises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // set to true to ensure no more processes are being spawned.
                        this.killOffSignal = true;
                        cleanUpPromises = [];
                        if (match.agents) {
                            match.agents.forEach(function (agent) {
                                // kill the process if it is not null
                                if (agent.process) {
                                    cleanUpPromises.push(_this.kill(agent));
                                }
                                // remove the agent files if on secureMode and double check it is the temporary directory
                                if (agent.options.secureMode) {
                                    var tmpdir = os_1.default.tmpdir();
                                    if (agent.cwd.slice(0, tmpdir.length) === tmpdir) {
                                        cleanUpPromises.push(System_1.removeDirectory(agent.cwd));
                                    }
                                    else {
                                        _this.log.error('couldn\'t remove agent files while in secure mode');
                                    }
                                }
                            });
                        }
                        return [4 /*yield*/, Promise.all(cleanUpPromises)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Kills an agent and closes the process, and no longer attempts to receive coommands from it anymore
     * @param agent - the agent to kill off
     */
    MatchEngine.prototype.kill = function (agent) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, agent._terminate()];
                    case 1:
                        _a.sent();
                        agent._currentMoveResolve();
                        this.log.system("Killed off agent " + agent.id + " - " + agent.name);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns a promise that resolves with all the commands loaded from the previous time step of the provided match
     * This coordinates all the Agents and waits for each one to finish their step
     * @param match - The match to get commands from agents for
     * @returns a promise that resolves with an array of {@link MatchEngine.Command} elements, holding the command and id
     * of the agent that sent it
     */
    MatchEngine.prototype.getCommands = function (match) {
        var _this = this;
        return new Promise(function (resolve) {
            var commands = [];
            var nonTerminatedAgents = match.agents.filter(function (agent) {
                return !agent.isTerminated();
            });
            var allAgentMovePromises = nonTerminatedAgents.map(function (agent) {
                return agent._currentMovePromise;
            });
            Promise.all(allAgentMovePromises).then(function () {
                _this.log.system("All move promises resolved");
                match.agents.forEach(function (agent) {
                    // TODO: Add option to store sets of commands delimited by '\n' for an Agent as different sets of commands /// for that Agent. Default right now is store every command delimited by the delimiter
                    // for each set of commands delimited by '\n' in stdout of process, split it by delimiter and push to 
                    // commands
                    agent.currentMoveCommands.forEach(function (commandString) {
                        commandString.split(_this.engineOptions.commandDelimiter).forEach(function (c) {
                            // we don't accept '' as commands.
                            if (c !== '') {
                                commands.push({ command: c, agentID: agent.id });
                            }
                        });
                    });
                });
                _this.log.system2("Agent commands at end of time step " + match.timeStep + " to be sent to match on time step " + (match.timeStep + 1) + " ");
                _this.log.system2(commands.length ? JSON.stringify(commands) : 'No commands');
                resolve(commands);
            });
        });
    };
    /**
     * Sends a message to a particular process governed by an agent in a specified match specified by the agentID
     * @param match - the match to work with
     * @param message - the message to send to agent's stdin
     * @param agentID - id that specifies the agent in the match to send the message to
     */
    MatchEngine.prototype.send = function (match, message, agentID) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var agent = match.idToAgentsMap.get(agentID);
            if (!agent.process.stdin.destroyed && !agent.isTerminated()) {
                agent.process.stdin.write(message + "\n", function (error) {
                    if (error)
                        reject(error);
                    resolve(true);
                });
            }
            else {
                _this.log.error("Agent " + agentID + " - " + agent.name + " - has been killed off already, can't send messages now");
                resolve(false);
            }
        });
    };
    /**
     * TODO: Initialize a custom design based match and run through some basic security measures
     * @param match - The match to initialize with a custom design
     */
    MatchEngine.prototype.initializeCustom = function (match) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, true];
            });
        });
    };
    /**
     * Run a custom match. A custom match much print to stdout all relevant data to be used by the engine and
     * Dimensions framework. All output after the conclude command from {@link Design.OverrideOptions} is outputted
     * is stored as a list of new line delimited strings and returned as the match results. The match must exit with
     * exit code 0 to be marked as succesfully complete and the processing of results stops and this function resolves
     * @param match - the match to run
     */
    MatchEngine.prototype.runCustom = function (match) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.overrideOptions.active == false) {
                reject(new DimensionError_1.FatalError('Override was not set active! Make sure to set the overide.active field to true'));
            }
            var cmd = _this.overrideOptions.command;
            var parsed = _this.parseCustomArguments(match, _this.overrideOptions.arguments);
            // spawn the match process with the parsed arguments
            var matchProcessTimer;
            // in secure mode, spawn given script as root user. User is required to spawn their match with 
            // sudo -H -u dimensions_bot to ensure security
            if (match.configs.secureMode) {
                match.matchProcess = child_process_1.spawn('sudo', __spreadArrays(['-H', '-u', exports.ROOT_USER, cmd], parsed)).on('error', function (err) {
                    if (err)
                        throw err;
                });
                _this.log.system(match.name + " | id: " + match.id + " - spawned: sudo -H -u " + exports.ROOT_USER + " " + cmd + " " + parsed.join(' '));
            }
            else {
                match.matchProcess = child_process_1.spawn(cmd, parsed).on('error', function (err) {
                    if (err)
                        throw err;
                });
                _this.log.system(match.name + " | id: " + match.id + " - spawned: " + cmd + " " + parsed.join(' '));
            }
            var matchTimedOut = false;
            // set up timer if specified
            if (_this.overrideOptions.timeout !== null) {
                matchProcessTimer = setTimeout(function () {
                    _this.log.system(match.name + " | id: " + match.id + " - Timed out");
                    match.matchProcess.kill('SIGKILL');
                    matchTimedOut = true;
                }, _this.overrideOptions.timeout);
            }
            var processingStage = false;
            match.matchProcess.stdout.on('readable', function () {
                var data;
                while (data = match.matchProcess.stdout.read()) {
                    // split chunks into line by line and handle each line of output
                    var strs = ("" + data).split('\n');
                    for (var i = 0; i < strs.length; i++) {
                        var str = strs[i];
                        // skip empties
                        if (str === '')
                            continue;
                        // if we reached conclude command, default being D_MATCH_FINISHED, we start the processing stage
                        if (str === _this.overrideOptions.conclude_command) {
                            processingStage = true;
                        }
                        // else if we aren't in the processing stage
                        else if (!processingStage) {
                            // store all stdout 
                            match.state.matchOutput.push(str);
                        }
                        // otherwise we are in processing stage
                        else {
                            // store into results
                            match.results.push(str);
                        }
                    }
                }
            });
            match.matchProcess.stdout.on('close', function (code) {
                _this.log.system(match.name + " | id: " + match.id + " - exited with code " + code);
                if (matchTimedOut) {
                    reject(new DimensionError_1.MatchError('Match timed out'));
                }
                else {
                    clearTimeout(matchProcessTimer);
                    resolve(match.results);
                }
                // remove the agent files if on secureMode and double check it is the temporary directory
                match.agents.forEach(function (agent) {
                    if (agent.options.secureMode) {
                        var tmpdir = os_1.default.tmpdir();
                        if (agent.cwd.slice(0, tmpdir.length) === tmpdir) {
                            child_process_1.exec("sudo rm -rf " + agent.cwd);
                        }
                        else {
                            _this.log.error('couldn\'t remove agent files while in secure mode');
                        }
                    }
                });
            });
        });
    };
    /**
     * Attempts to stop a {@link Match} based on a custom {@link Design}
     * @param match - the match to stop
     */
    MatchEngine.prototype.stopCustom = function (match) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // attempt to stop the match
                match.matchProcess.kill('SIGSTOP');
                return [2 /*return*/];
            });
        });
    };
    ;
    /**
     * Attempts to resume a {@link Match} based on a custom {@link Design}
     * @param match - the match to resume
     */
    MatchEngine.prototype.resumeCustom = function (match) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // attempt to resume the match
                match.matchProcess.kill('SIGCONT');
                return [2 /*return*/];
            });
        });
    };
    ;
    /**
     * Attempts to kill and clean up anything else for a custom design based match
     * @param match - the match to kill and clean up
     */
    MatchEngine.prototype.killAndCleanCustom = function (match) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (match.matchProcess)
                    match.matchProcess.kill('SIGKILL');
                return [2 /*return*/];
            });
        });
    };
    /**
     * Parses a list of arguments for a given match and populates relevant strings as needed
     * @param match - the match to parse arguments for
     * @param args - the arguments to parse
     */
    MatchEngine.prototype.parseCustomArguments = function (match, args) {
        if (match.matchStatus === Match_1.Match.Status.UNINITIALIZED) {
            throw new DimensionError_1.FatalError("Match " + match.id + " - " + match.name + " is not initialized yet");
        }
        var parsed = [];
        for (var i = 0; i < args.length; i++) {
            switch (args[i]) {
                case MatchEngine.DynamicDataStrings.D_FILES:
                    match.agents.forEach(function (agent) {
                        parsed.push(agent.file);
                    });
                    break;
                case MatchEngine.DynamicDataStrings.D_TOURNAMENT_IDS:
                    match.agents.forEach(function (agent) {
                        // pass in tournament ID string if it exists, otherwise pass in 0
                        parsed.push(agent.tournamentID.id ? agent.tournamentID : '0');
                    });
                    break;
                case MatchEngine.DynamicDataStrings.D_AGENT_IDS:
                    match.agents.forEach(function (agent) {
                        parsed.push(agent.id);
                    });
                    break;
                case MatchEngine.DynamicDataStrings.D_MATCH_ID:
                    parsed.push(match.id);
                    break;
                case MatchEngine.DynamicDataStrings.D_MATCH_NAME:
                    parsed.push(match.name);
                    break;
                case MatchEngine.DynamicDataStrings.D_NAMES:
                    match.agents.forEach(function (agent) {
                        var parsedName = agent.name;
                        parsedName = parsedName.replace(/\//g, '-');
                        parsedName = parsedName.replace(/ /g, '_');
                        parsed.push(parsedName);
                    });
                    break;
                default:
                    parsed.push(args[i]);
                    break;
            }
        }
        return parsed;
    };
    /** approx extra buffer time given to agents due to engine processing for timeout mechanism */
    MatchEngine.timeoutBuffer = 25;
    return MatchEngine;
}());
exports.MatchEngine = MatchEngine;
(function (MatchEngine) {
    /**
     * Various policies available that describe the requirements before an agent is marked as done with sending commands
     * at some time step
     */
    var COMMAND_FINISH_POLICIES;
    (function (COMMAND_FINISH_POLICIES) {
        /**
         * Agent's finish their commands by sending a finish symbol, namely {@link EngineOptions.commandFinishSymbol}
         */
        COMMAND_FINISH_POLICIES["FINISH_SYMBOL"] = "finish_symbol";
        /**
         * Agent's finish their commands by either sending a finish symmbol or after they send
         * {@link EngineOptions.commandLines.max} lines
         */
        COMMAND_FINISH_POLICIES["LINE_COUNT"] = "line_count";
        /**
         * Custom finishing policy provided by user. Not allowed at the moment
         */
        COMMAND_FINISH_POLICIES["CUSTOM"] = "custom";
        // TODO: implement custom finish policy
    })(COMMAND_FINISH_POLICIES = MatchEngine.COMMAND_FINISH_POLICIES || (MatchEngine.COMMAND_FINISH_POLICIES = {}));
    /** Standard ways for commands from agents to be streamed to the MatchEngine for the {@link Design} to handle */
    var COMMAND_STREAM_TYPE;
    (function (COMMAND_STREAM_TYPE) {
        /** First come first serve for commands run. Not implemented */
        COMMAND_STREAM_TYPE["PARALLEL"] = "parallel";
        /** Each agent's set of commands is run before the next agent */
        COMMAND_STREAM_TYPE["SEQUENTIAL"] = "sequential";
    })(COMMAND_STREAM_TYPE = MatchEngine.COMMAND_STREAM_TYPE || (MatchEngine.COMMAND_STREAM_TYPE = {}));
    ;
    var AGENT_EVENTS;
    (function (AGENT_EVENTS) {
        /**
         * Event emitted by process of {@link Agent} when memory limit is exceeded
         */
        AGENT_EVENTS["EXCEED_MEMORY_LIMIT"] = "exceedMemoryLimit";
        /**
         * Event emitted by process of {@link Agent} when it times out.
         */
        AGENT_EVENTS["TIMEOUT"] = "timeout";
    })(AGENT_EVENTS = MatchEngine.AGENT_EVENTS || (MatchEngine.AGENT_EVENTS = {}));
    /**
     * Dynammic Data strings are strings in the {@link OverrideOptions} arguments array that are automatically replaced
     * with dynamic data as defined in the documentation of these enums
     */
    var DynamicDataStrings;
    (function (DynamicDataStrings) {
        /**
         * `D_FILES` is automatically populated by a space seperated string list of the file paths provided for each of the
         * agents competing in a match.
         *
         * NOTE, these paths don't actually need to be files, they can be directories or anything that works with
         * your own command and design
         *
         * @example Suppose the paths to the sources the agents operate on are `path1`, `path2`, `path3`. Then `D_FILES`
         * will be passed into your command as `path1 path2 path3`
         */
        DynamicDataStrings["D_FILES"] = "D_FILES";
        /**
         * `D_AGENT_IDS` is automatically populated by a space seperated string list of the agent IDs of every agent being
         * loaded into a match in the same order as D_FILES. This should always be sorted by default as agents are loaded
         * in order from agent ID `0` to agent ID `n-1`in a `n` agent match
         *
         * @example Suppose a match is running with agents with IDs `0, 1, 2, 3`. Then `D_AGENT_IDS` will be passed into
         * your command as `0 1 2 3`
         */
        DynamicDataStrings["D_AGENT_IDS"] = "D_AGENT_IDS";
        /**
         * `D_TOURNAMENT_IDS` is automatically populated by a space seperated string list of the tournament ID numbers of
         * the agents being loaded into the match in the same order. If no tournament is being run all the ID numbers will
         * default to 0 but still be passed in to the command you give for the override configurations
         *
         * @example Suppose a match in a tournament is running 2 agents with tournament IDs `Qb6NyTxufGGU`, `EGg3tSN2KUgl`
         * Then `D_TOURNAMENT_IDS` will be passed into your command as `Qb6NyTxufGGU EGg3tSN2KUgl`
         */
        DynamicDataStrings["D_TOURNAMENT_IDS"] = "D_TOURNAMENT_IDS";
        /**
         * D_MATCH_ID is automatically replaced with the id of the match being run
         *
         * @example Suppose the match has ID `eF1uEacgfgMm`, then `D_MATCH_ID` is passed into your command as `eF1uEacgfgMm`
         */
        DynamicDataStrings["D_MATCH_ID"] = "D_MATCH_ID";
        /**
         * D_MATCH_NAME is automatically replaced with the name of the match being run
         *
         * @example Suppose the match has name 'my_match'. Then `D_MATCH_NAME` is passed into your commnad as `my_match`
         */
        DynamicDataStrings["D_MATCH_NAME"] = "D_MATCH_NAME";
        /**
         * D_NAMES is automatically replaced with the names of the agents
         *
         * @example Suppose the agents 0 and 1 had names `bob, richard`. Then `D_NAMES` is passed into your commnad as
         * `bob richard`
         */
        DynamicDataStrings["D_NAMES"] = "D_NAMES";
    })(DynamicDataStrings = MatchEngine.DynamicDataStrings || (MatchEngine.DynamicDataStrings = {}));
})(MatchEngine = exports.MatchEngine || (exports.MatchEngine = {}));
exports.MatchEngine = MatchEngine;
/** name of the bot user that owns the agent's process */
exports.BOT_USER = 'dimensions_bot';
/** @ignore */
exports.ROOT_USER = 'root';
//# sourceMappingURL=index.js.map