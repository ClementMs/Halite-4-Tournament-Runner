"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var child_process_1 = require("child_process");
var path_1 = __importDefault(require("path"));
var fs_1 = __importDefault(require("fs"));
var os_1 = __importDefault(require("os"));
var tree_kill_1 = __importDefault(require("tree-kill"));
var Logger_1 = require("../Logger");
var DimensionError_1 = require("../DimensionError");
var MatchEngine_1 = require("../MatchEngine");
var DeepMerge_1 = require("../utils/DeepMerge");
var utils_1 = require("../utils");
var DeepCopy_1 = require("../utils/DeepCopy");
/**
 * @class Agent
 * @classdesc The agent is what participates in a match and contains details on the files powering the agent, the
 * process associated and many other details.
 *
 * Reads in a file source for the code and copies the bot folder to a temporary directory in secure modes
 * and creates an `Agent` for use in the {@link MatchEngine} and {@link Match}
 *
 * This is a class that should not be broken. If something goes wrong, this should always throw a error. It is
 * expected that agents are used knowing beforehand that the file given is validated
 */
var Agent = /** @class */ (function () {
    function Agent(file, options) {
        /**
         * This agent's ID in a match. It is always a non-negative integer and agents in a match are always numbered
         * `0, 1, 2, ...n` where there are `n` agents.
         */
        this.id = 0;
        /**
         * A tournmanet ID if Agent is generated from within a {@link Tournament}
         */
        this.tournamentID = null;
        /** The command used to run the file */
        this.cmd = null;
        /**
         * The agent's options
         */
        this.options = DeepCopy_1.deepCopy(Agent.OptionDefaults);
        /** internal buffer to store stdout from an agent that has yet to be delimited / used */
        this._buffer = [];
        /** Interval that periodically watches the memory usage of the process associated with this agent */
        this.memoryWatchInterval = null;
        /**
         * The associatted process running the Agent
         */
        this.process = null;
        /**
         * Current status of the agent
         */
        this.status = Agent.Status.UNINITIALIZED;
        /** The commands collected so far for the current move */
        this.currentMoveCommands = [];
        /* istanbul ignore next */
        this._currentMoveResolve = function () { }; // set as a dummy function
        /** A number that counts the number of times the agent has essentially interacted with the {@link MatchEngine} */
        this.agentTimeStep = 0;
        /** Clears out the timer associated with the agent during a match */
        this._clearTimer = function () { };
        this.log = new Logger_1.Logger();
        /** whether agent is allowed to send commands. Used to help ignore extra output from agents */
        this.allowedToSendCommands = true;
        this.creationDate = new Date();
        this.options = DeepMerge_1.deepMerge(this.options, DeepCopy_1.deepCopy(options));
        this.log.level = this.options.loggingLevel;
        this.ext = path_1.default.extname(file);
        var pathparts = file.split('/');
        this.cwd = pathparts.slice(0, -1).join('/');
        this.src = pathparts.slice(-1).join('/');
        this.srcNoExt = this.src.slice(0, -this.ext.length);
        // check if file exists
        if (!fs_1.default.existsSync(file)) {
            throw new DimensionError_1.AgentFileError(file + " does not exist, check if file path provided is correct", this.id);
        }
        // check if folder is valid
        if (!fs_1.default.existsSync(this.cwd)) {
            throw new DimensionError_1.AgentDirectoryError(this.cwd + " directory does not exist, check if directory provided through the file is correct", this.id);
        }
        this.file = file;
        switch (this.ext) {
            case '.py':
                this.cmd = 'python';
                break;
            case '.js':
            case '.ts':
                this.cmd = 'node';
                break;
            case '.java':
                this.cmd = 'java';
                break;
            case '.php':
                this.cmd = 'php';
                break;
            case '.c':
            case '.cpp':
            case '.go':
                this.cmd = '';
                break;
            default:
        }
        // if we are running in secure mode, we copy the agent over to a temporary directory
        if (this.options.secureMode) {
            var botDir = path_1.default.join(os_1.default.tmpdir(), '/dbot');
            if (!fs_1.default.existsSync(botDir)) {
                // create the temporary bot directory and change perms so that other users cannot read it
                fs_1.default.mkdirSync(botDir);
                child_process_1.execSync("sudo chown " + MatchEngine_1.ROOT_USER + " " + botDir);
                child_process_1.execSync("sudo chmod o-r " + botDir);
                // This makes it hard for bots to try to look for other bots and copy code
                // without access to reading the directory
            }
            // create a temporary directory generated as bot-<12 char nanoID>-<6 random chars.
            var tempDir = fs_1.default.mkdtempSync(path_1.default.join(botDir, "/bot-" + utils_1.genID(12) + "-"));
            var stats = fs_1.default.statSync(this.cwd);
            if (stats.isDirectory()) {
                // copy all files in the bot directory to the temporary one
                child_process_1.execSync("sudo cp -R " + this.cwd + "/* " + tempDir);
                // set BOT_USER as the owner
                child_process_1.execSync("sudo chown -R " + MatchEngine_1.BOT_USER + " " + tempDir);
                // update the current working directory and file fields.
                this.cwd = tempDir;
                this.file = path_1.default.join(tempDir, this.src);
            }
            else {
                throw new DimensionError_1.AgentDirectoryError(this.cwd + " is not a directory", this.id);
            }
        }
        if (this.options.id !== null) {
            this.id = options.id;
        }
        else {
            throw new DimensionError_1.AgentMissingIDError("No id provided for agent using " + file, this.id);
        }
        if (this.options.name) {
            this.name = this.options.name;
        }
        else {
            this.name = "agent_" + this.id;
        }
        if (this.options.tournamentID) {
            this.tournamentID = options.tournamentID;
            this.name = this.tournamentID.name;
        }
        this.log.system("Created agent: " + this.name);
        // set agent as ready
        this.status = Agent.Status.READY;
    }
    /**
     * Install whatever is needed through a `install.sh` file in the root of the bot folder
     */
    Agent.prototype._install = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // if there is a install.sh file, use it
            if (fs_1.default.existsSync(path_1.default.join(_this.cwd, 'install.sh'))) {
                // run in restricted bash if in secureMode
                var p = void 0;
                var installTimer_1 = setTimeout(function () {
                    reject(new DimensionError_1.AgentInstallTimeoutError('Agent went over install time during the install stage', _this.id));
                }, _this.options.maxInstallTime);
                if (_this.options.secureMode) {
                    p = child_process_1.spawn('sudo', ['-H', '-u', MatchEngine_1.BOT_USER, 'rbash', 'install.sh'], {
                        cwd: _this.cwd
                    });
                }
                else {
                    p = child_process_1.spawn('bash', ['install.sh'], {
                        cwd: _this.cwd,
                        stdio: 'ignore'
                    });
                }
                var chunks_1 = [];
                p.stdout.on('data', function (chunk) {
                    chunks_1.push(chunk);
                });
                p.stderr.on('data', function (chunk) {
                    chunks_1.push(chunk);
                });
                p.on('error', function (err) {
                    clearTimeout(installTimer_1);
                    reject(err);
                });
                p.on('close', function (code) {
                    clearTimeout(installTimer_1);
                    if (code === 0) {
                        resolve();
                    }
                    else {
                        reject(new DimensionError_1.AgentInstallError("A install time error occured. Install step for agent " + _this.id + " exited with code: " + code + "; Installing " + path_1.default.join(_this.cwd, 'install.sh') + "; Install Output:\n" + chunks_1.join(''), _this.id));
                    }
                });
            }
            else {
                resolve();
            }
        });
    };
    /**
     * Compile whatever is needed and validate files. Called by {@link MatchEngine} and has a timer set by the
     * maxCompileTime option in {@link Agent.Options}
     */
    Agent.prototype._compile = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var p;
            var compileTimer = setTimeout(function () {
                reject(new DimensionError_1.AgentCompileTimeoutError('Agent went over compile time during the compile stage', _this.id));
            }, _this.options.maxCompileTime);
            if (_this.options.compileCommands[_this.ext]) {
                p = child_process_1.spawn("sudo", __spreadArrays(_this.options.compileCommands[_this.ext], [_this.src]), {
                    cwd: _this.cwd
                });
            }
            else {
                switch (_this.ext) {
                    case '.py':
                    case '.php':
                        resolve();
                        break;
                    // TODO: Make these compile options configurable
                    case '.js':
                        p = child_process_1.spawn("sudo", ['node', '--check', _this.src], {
                            cwd: _this.cwd
                        });
                        break;
                    case '.ts':
                        p = child_process_1.spawn("sudo", __spreadArrays("tsc --esModuleInterop --allowJs -m commonjs --lib es5".split(' '), [_this.src]), {
                            cwd: _this.cwd
                        });
                        break;
                    case '.go':
                        p = child_process_1.spawn("sudo", ['go', 'build', '-o', _this.srcNoExt + ".out", _this.src], {
                            cwd: _this.cwd
                        });
                        break;
                    case '.cpp':
                        p = child_process_1.spawn("sudo", ['g++', '-std=c++11', '-O3', '-o', _this.srcNoExt + ".out", _this.src], {
                            cwd: _this.cwd
                        });
                        break;
                    case '.c':
                        p = child_process_1.spawn("sudo", ['gcc', '-O3', '-o', _this.srcNoExt + ".out", _this.src], {
                            cwd: _this.cwd
                        });
                        break;
                    case '.java':
                        p = child_process_1.spawn("sudo", ['javac', _this.src], {
                            cwd: _this.cwd
                        });
                        break;
                    default:
                        reject(new DimensionError_1.NotSupportedError("Language with extension " + _this.ext + " is not supported at the moment"));
                        break;
                }
            }
            if (p) {
                p.on('error', function (err) {
                    clearTimeout(compileTimer);
                    reject(err);
                });
                var chunks_2 = [];
                p.stdout.on('data', function (chunk) {
                    chunks_2.push(chunk);
                });
                p.stderr.on('data', function (chunk) {
                    chunks_2.push(chunk);
                });
                p.on('close', function (code) {
                    clearTimeout(compileTimer);
                    if (code === 0) {
                        resolve();
                    }
                    else {
                        reject(new DimensionError_1.AgentCompileError("A compile time error occured. Compile step for agent " + _this.id + " exited with code: " + code + "; Compiling " + _this.file + "; Compile Output:\n" + chunks_2.join(''), _this.id));
                    }
                });
            }
            else {
                clearTimeout(compileTimer);
            }
        });
    };
    /**
     * Spawn the process and return the process
     */
    Agent.prototype._spawn = function () {
        return __awaiter(this, void 0, void 0, function () {
            var p, p;
            return __generator(this, function (_a) {
                if (this.options.runCommands[this.ext]) {
                    p = this._spawnProcess(this.options.runCommands[this.ext][0], __spreadArrays(this.options.runCommands[this.ext].slice(1), [this.src]));
                    return [2 /*return*/, p];
                }
                else {
                    switch (this.ext) {
                        case '.py':
                        case '.js':
                        case '.php':
                            p = this._spawnProcess(this.cmd, [this.src]);
                            return [2 /*return*/, p];
                        case '.ts':
                            return [2 /*return*/, this._spawnProcess(this.cmd, [this.srcNoExt + '.js'])];
                        case '.java':
                            return [2 /*return*/, this._spawnProcess(this.cmd, [this.srcNoExt])];
                        case '.c':
                        case '.cpp':
                        case '.go':
                            return [2 /*return*/, this._spawnProcess('./' + this.srcNoExt + '.out', [])];
                        default:
                            throw new DimensionError_1.NotSupportedError("Language with extension " + this.ext + " is not supported yet");
                    }
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Spawns process in this.cwd accordingly and uses the configs accordingly.
     * Resolves with the process if spawned succesfully
     *
     * Note, we are spawning detached so we can kill off all sub processes if they are made. See {@link _terminate} for
     * explanation
     */
    Agent.prototype._spawnProcess = function (command, args) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.options.secureMode) {
                var p = child_process_1.spawn('sudo', __spreadArrays(['-H', '-u', MatchEngine_1.BOT_USER, command], args), {
                    cwd: _this.cwd,
                    detached: false,
                }).on('error', function (err) { reject(err); });
                resolve(p);
            }
            else {
                var p = child_process_1.spawn(command, args, {
                    cwd: _this.cwd,
                    detached: false
                }).on('error', function (err) { reject(err); });
                resolve(p);
            }
        });
    };
    /**
     * Returns true if this agent was terminated and no longer send or receive emssages
     */
    Agent.prototype.isTerminated = function () {
        return this.status === Agent.Status.KILLED;
    };
    /**
     * Terminates this agent by stopping all related processes and remove any temporary directory
     */
    Agent.prototype._terminate = function () {
        var _this = this;
        this.status = Agent.Status.KILLED;
        return new Promise(function (resolve, reject) {
            tree_kill_1.default(_this.process.pid, 'SIGKILL', function (err) {
                _this._clearTimer();
                clearInterval(_this.memoryWatchInterval);
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    };
    /**
     * Disallow an agent from sending more commands
     */
    Agent.prototype._disallowCommands = function () {
        this.allowedToSendCommands = false;
    };
    /**
     * Allow agent to send commands again
     */
    Agent.prototype._allowCommands = function () {
        this.allowedToSendCommands = true;
    };
    /**
     * Check if agent is set to be allowed to send commands. The {@link EngineOptions} affect when this is flipped
     */
    Agent.prototype.isAllowedToSendCommands = function () {
        return this.allowedToSendCommands;
    };
    /**
     * Setup the agent timer clear out method
     */
    Agent.prototype._setTimeout = function (fn, delay) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var timer = setTimeout(function () {
            fn.apply(void 0, args);
        }, delay);
        this._clearTimer = function () {
            clearTimeout(timer);
        };
    };
    /**
     * Stop this agent from more outputs and mark it as done for now and awaiting for updates
     */
    Agent.prototype._finishMove = function () {
        this._clearTimer();
        // Resolve move and tell engine in `getCommands` this agent is done outputting commands and awaits input
        this._currentMoveResolve();
        // stop the process for now from sending more output and disallow commmands to ignore rest of output
        this.process.kill('SIGSTOP');
        this._disallowCommands();
    };
    // Start an Agent's move and setup the promise structures
    Agent.prototype._setupMove = function () {
        var _this = this;
        // allows agent to send commands; increment time; clear past commands; reset the promise structure
        this.allowedToSendCommands = true;
        this.agentTimeStep++;
        this.currentMoveCommands = [];
        this._currentMovePromise = new Promise(function (resolve, reject) {
            _this._currentMoveResolve = resolve;
            _this._currentMoveReject = reject;
        });
    };
    /**
     * Generates a list of agents for use
     * @param files List of files to use to make agents or a list of objects with a file key for the file path to the bot
     *              and a name key for the name of the agent
     * @param loggingLevel - the logging level for all these agents
     * @param secureMode - whether to generate the agent securely. @default `true`
     */
    Agent.generateAgents = function (files, options) {
        if (files.length === 0) {
            throw new DimensionError_1.AgentFileError('No files provided to generate agents with!', -1);
        }
        var agents = [];
        if (typeof files[0] === 'string') {
            files.forEach(function (file, index) {
                var configs = DeepCopy_1.deepCopy(options);
                configs.id = index;
                agents.push(new Agent(file, configs));
            });
        }
        //@ts-ignore
        else if (files[0].name !== undefined) {
            files.forEach(function (info, index) {
                var configs = DeepCopy_1.deepCopy(options);
                configs.id = index;
                configs.name = info.name;
                agents.push(new Agent(info.file, configs));
            });
        }
        else {
            files.forEach(function (info, index) {
                var configs = DeepCopy_1.deepCopy(options);
                configs.id = index;
                configs.tournamentID = info.tournamentID;
                agents.push(new Agent(info.file, configs));
            });
        }
        return agents;
    };
    return Agent;
}());
exports.Agent = Agent;
(function (Agent) {
    /**
     * Status enums for an Agent
     */
    var Status;
    (function (Status) {
        /** When agent is just created */
        Status["UNINITIALIZED"] = "uninitialized";
        /** Agent is ready too be used by the {@link MatchEngine} in a {@link Match} */
        Status["READY"] = "ready";
        /** Agent is currently running */
        Status["RUNNING"] = "running";
        /** Agent crashed somehow */
        Status["CRASHED"] = "crashed";
        /** Agent is finished and no longer in use after {@link Match} ended or was prematurely killed */
        Status["KILLED"] = "killed";
        /** Agent is currently not running */
        Status["STOPPED"] = "stopped";
    })(Status = Agent.Status || (Agent.Status = {}));
    /**
     * Default Agent options
     */
    Agent.OptionDefaults = {
        secureMode: false,
        loggingLevel: Logger_1.Logger.LEVEL.INFO,
        id: null,
        tournamentID: null,
        name: null,
        maxInstallTime: 300000,
        maxCompileTime: 60000,
        runCommands: {},
        compileCommands: {}
    };
})(Agent = exports.Agent || (exports.Agent = {}));
exports.Agent = Agent;
//# sourceMappingURL=index.js.map