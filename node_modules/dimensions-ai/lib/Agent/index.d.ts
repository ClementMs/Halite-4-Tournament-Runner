/// <reference types="node" />
import { ChildProcess } from "child_process";
import { Logger } from "../Logger";
import { Tournament } from "../Tournament";
import { DeepPartial } from "../utils/DeepPartial";
/**
 * @class Agent
 * @classdesc The agent is what participates in a match and contains details on the files powering the agent, the
 * process associated and many other details.
 *
 * Reads in a file source for the code and copies the bot folder to a temporary directory in secure modes
 * and creates an `Agent` for use in the {@link MatchEngine} and {@link Match}
 *
 * This is a class that should not be broken. If something goes wrong, this should always throw a error. It is
 * expected that agents are used knowing beforehand that the file given is validated
 */
export declare class Agent {
    /**
     * This agent's ID in a match. It is always a non-negative integer and agents in a match are always numbered
     * `0, 1, 2, ...n` where there are `n` agents.
     */
    id: Agent.ID;
    /**
     * A tournmanet ID if Agent is generated from within a {@link Tournament}
     */
    tournamentID: Tournament.ID;
    /**
     * Name of the agent
     * @default `agent_[agent.id]`
     */
    name: string;
    /** The source path to the file that runs the agent */
    src: string;
    /** The extension of the file */
    ext: string;
    /** file without extension */
    srcNoExt: string;
    /**
     * The current working directory of the source file. If in insecure mode, this is always a temporary directory that
     * will get deleted later.
     */
    cwd: string;
    /** The command used to run the file */
    cmd: string;
    /**
     * The original file path provided
     */
    file: string;
    /**
     * The agent's options
     */
    options: Agent.Options;
    /**
     * Creation date of the agent
     */
    creationDate: Date;
    /** internal buffer to store stdout from an agent that has yet to be delimited / used */
    _buffer: Array<string>;
    /** Interval that periodically watches the memory usage of the process associated with this agent */
    memoryWatchInterval: any;
    /**
     * The associatted process running the Agent
     */
    process: ChildProcess;
    /**
     * Current status of the agent
     */
    status: Agent.Status;
    /** The commands collected so far for the current move */
    currentMoveCommands: Array<string>;
    /** a promise that resolves when the Agent's current move in the {@link Match} is finished */
    _currentMovePromise: Promise<void>;
    _currentMoveResolve: Function;
    _currentMoveReject: Function;
    /** A number that counts the number of times the agent has essentially interacted with the {@link MatchEngine} */
    agentTimeStep: number;
    /** Clears out the timer associated with the agent during a match */
    _clearTimer: Function;
    private log;
    /** whether agent is allowed to send commands. Used to help ignore extra output from agents */
    private allowedToSendCommands;
    constructor(file: string, options: Partial<Agent.Options>);
    /**
     * Install whatever is needed through a `install.sh` file in the root of the bot folder
     */
    _install(): Promise<void>;
    /**
     * Compile whatever is needed and validate files. Called by {@link MatchEngine} and has a timer set by the
     * maxCompileTime option in {@link Agent.Options}
     */
    _compile(): Promise<void>;
    /**
     * Spawn the process and return the process
     */
    _spawn(): Promise<ChildProcess>;
    /**
     * Spawns process in this.cwd accordingly and uses the configs accordingly.
     * Resolves with the process if spawned succesfully
     *
     * Note, we are spawning detached so we can kill off all sub processes if they are made. See {@link _terminate} for
     * explanation
     */
    _spawnProcess(command: string, args: Array<string>): Promise<ChildProcess>;
    /**
     * Returns true if this agent was terminated and no longer send or receive emssages
     */
    isTerminated(): boolean;
    /**
     * Terminates this agent by stopping all related processes and remove any temporary directory
     */
    _terminate(): Promise<void>;
    /**
     * Disallow an agent from sending more commands
     */
    _disallowCommands(): void;
    /**
     * Allow agent to send commands again
     */
    _allowCommands(): void;
    /**
     * Check if agent is set to be allowed to send commands. The {@link EngineOptions} affect when this is flipped
     */
    isAllowedToSendCommands(): boolean;
    /**
     * Setup the agent timer clear out method
     */
    _setTimeout(fn: Function, delay: number, ...args: any[]): void;
    /**
     * Stop this agent from more outputs and mark it as done for now and awaiting for updates
     */
    _finishMove(): void;
    _setupMove(): void;
    /**
     * Generates a list of agents for use
     * @param files List of files to use to make agents or a list of objects with a file key for the file path to the bot
     *              and a name key for the name of the agent
     * @param loggingLevel - the logging level for all these agents
     * @param secureMode - whether to generate the agent securely. @default `true`
     */
    static generateAgents(files: Array<String> | Array<{
        file: string;
        name: string;
    }> | Array<{
        file: string;
        tournamentID: Tournament.ID;
    }>, options: DeepPartial<Agent.Options>): Array<Agent>;
}
export declare module Agent {
    /**
     * Status enums for an Agent
     */
    enum Status {
        /** When agent is just created */
        UNINITIALIZED = "uninitialized",
        /** Agent is ready too be used by the {@link MatchEngine} in a {@link Match} */
        READY = "ready",
        /** Agent is currently running */
        RUNNING = "running",
        /** Agent crashed somehow */
        CRASHED = "crashed",
        /** Agent is finished and no longer in use after {@link Match} ended or was prematurely killed */
        KILLED = "killed",
        /** Agent is currently not running */
        STOPPED = "stopped"
    }
    /**
     * Agent ID. Always a non-negative integer and all agents in a match have IDs that are strictly increasing from `0`
     *
     * For example, in a 4 agent match, the ids are `0, 1, 2, 3`.
     */
    type ID = number;
    /**
     * Agent options interface
     */
    interface Options {
        /** Name of agent */
        name: string;
        /**
         * Whether or not to spawn agent securely and avoid malicious activity
         *
         * When set to true, the agent's file and the directory containing the file are copied over to a temporary directory
         * of which there is restricted access. By default this is false
         *
         * @default `false` (always inherited from the match configs, see {@link Match.Configs})
         */
        secureMode: boolean;
        /** A specified ID to use for the agent */
        id: ID;
        /** A specified tournament ID linking an agent to the {@link Tournament} and {@link Player} it belongs to */
        tournamentID: Tournament.ID;
        /** Logging level of this agent */
        loggingLevel: Logger.LEVEL;
        /**
         * Maximium time allowed for an agent to spend on the installing step
         * @default 5 minutes (300,000 ms)
         */
        maxInstallTime: number;
        /**
         * Maximum time allowed to be spent compiling
         * @default 1 minute (60,000 ms)
         */
        maxCompileTime: number;
        /**
         * Map from extension type to set of commands used to compile this agent instead of the defaults. When there is no
         * mapping default is used
         *
         * @default `null`
         */
        compileCommands: {
            [x in string]: Array<string>;
        };
        /**
         * Map from extension type to set of commands used to run this agent instead of the defaults. When there is no
         * mapping default is used
         *
         * @default `null`
         */
        runCommands: {
            [x in string]: Array<string>;
        };
    }
    /**
     * Default Agent options
     */
    const OptionDefaults: Agent.Options;
}
